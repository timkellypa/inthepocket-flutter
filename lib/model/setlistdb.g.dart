// GENERATED CODE - DO NOT MODIFY BY HAND

part of 'setlistdb.dart';

// **************************************************************************
// SqfEntityGenerator
// **************************************************************************

// ignore_for_file: non_constant_identifier_names

//  These classes was generated by SqfEntity
//  Copyright (c) 2019, All rights reserved. Use of this source code is governed by a
//  Apache license that can be found in the LICENSE file.

//  To use these SqfEntity classes do following:
//  - import model.dart into where to use
//  - start typing ex:Setlist.select()... (add a few filters with fluent methods)...(add orderBy/orderBydesc if you want)...
//  - and then just put end of filters / or end of only select()  toSingle() / or toList()
//  - you can select one or return List<yourObject> by your filters and orders
//  - also you can batch update or batch delete by using delete/update methods instead of tosingle/tolist methods
//    Enjoy.. Huseyin Tokpunar

// BEGIN TABLES
// Setlist TABLE
class TableSetlist extends SqfEntityTableBase {
  TableSetlist() {
    // declare properties of EntityTable
    tableName = 'Setlist';
    primaryKeyName = 'row__id';
    primaryKeyType = PrimaryKeyType.text;
    useSoftDeleting = false;
    // when useSoftDeleting is true, creates a field named 'isDeleted' on the table, and set to '1' this field when item deleted (does not hard delete)

    // declare fields
    fields = [
      SqfEntityFieldBase('description', DbType.text),
      SqfEntityFieldBase('row__sortOrder', DbType.integer),
      SqfEntityFieldBase('date', DbType.datetime,
          minValue: DateTime.parse('1900-01-01')),
      SqfEntityFieldBase('location', DbType.text),
      SqfEntityFieldBase('setlistType', DbType.integer),
    ];
    super.init();
  }
  static SqfEntityTableBase? _instance;
  static SqfEntityTableBase get getInstance {
    return _instance = _instance ?? TableSetlist();
  }
}

// SetlistTrack TABLE
class TableSetlistTrack extends SqfEntityTableBase {
  TableSetlistTrack() {
    // declare properties of EntityTable
    tableName = 'SetlistTrack';
    primaryKeyName = 'row__id';
    primaryKeyType = PrimaryKeyType.text;
    useSoftDeleting = false;
    // when useSoftDeleting is true, creates a field named 'isDeleted' on the table, and set to '1' this field when item deleted (does not hard delete)

    // declare fields
    fields = [
      SqfEntityFieldBase('row__sortOrder', DbType.integer),
      SqfEntityFieldBase('notes', DbType.text),
      SqfEntityFieldRelationshipBase(
          TableSetlist.getInstance, DeleteRule.NO_ACTION,
          relationType: RelationType.ONE_TO_MANY, fieldName: 'setlistId'),
      SqfEntityFieldBase('setlistType', DbType.integer),
      SqfEntityFieldRelationshipBase(
          TableTrack.getInstance, DeleteRule.NO_ACTION,
          relationType: RelationType.ONE_TO_MANY, fieldName: 'trackId'),
    ];
    super.init();
  }
  static SqfEntityTableBase? _instance;
  static SqfEntityTableBase get getInstance {
    return _instance = _instance ?? TableSetlistTrack();
  }
}

// Track TABLE
class TableTrack extends SqfEntityTableBase {
  TableTrack() {
    // declare properties of EntityTable
    tableName = 'Track';
    primaryKeyName = 'row__id';
    primaryKeyType = PrimaryKeyType.text;
    useSoftDeleting = false;
    // when useSoftDeleting is true, creates a field named 'isDeleted' on the table, and set to '1' this field when item deleted (does not hard delete)

    // declare fields
    fields = [
      SqfEntityFieldBase('title', DbType.text),
      SqfEntityFieldBase('notes', DbType.text),
      SqfEntityFieldBase('row__sortOrder', DbType.integer, defaultValue: 1),
      SqfEntityFieldBase('spotifyId', DbType.text),
      SqfEntityFieldBase('spotifyAudioFeatures', DbType.text),
      SqfEntityFieldBase('countOutBars', DbType.text),
    ];
    super.init();
  }
  static SqfEntityTableBase? _instance;
  static SqfEntityTableBase get getInstance {
    return _instance = _instance ?? TableTrack();
  }
}

// Tempo TABLE
class TableTempo extends SqfEntityTableBase {
  TableTempo() {
    // declare properties of EntityTable
    tableName = 'Tempo';
    primaryKeyName = 'row__id';
    primaryKeyType = PrimaryKeyType.text;
    useSoftDeleting = false;
    // when useSoftDeleting is true, creates a field named 'isDeleted' on the table, and set to '1' this field when item deleted (does not hard delete)

    // declare fields
    fields = [
      SqfEntityFieldBase('row__sortOrder', DbType.integer),
      SqfEntityFieldBase('bpm', DbType.real),
      SqfEntityFieldBase('beatsPerBar', DbType.integer, defaultValue: 4),
      SqfEntityFieldBase('beatUnit', DbType.integer, defaultValue: 4),
      SqfEntityFieldBase('dottedQuarterAccent', DbType.bool,
          defaultValue: false),
      SqfEntityFieldBase('accentBeatsPerBar', DbType.integer, defaultValue: 1),
      SqfEntityFieldBase('numberOfBars', DbType.real, defaultValue: 1000),
      SqfEntityFieldRelationshipBase(
          TableTrack.getInstance, DeleteRule.NO_ACTION,
          relationType: RelationType.ONE_TO_MANY, fieldName: 'trackId'),
    ];
    super.init();
  }
  static SqfEntityTableBase? _instance;
  static SqfEntityTableBase get getInstance {
    return _instance = _instance ?? TableTempo();
  }
}
// END TABLES

// BEGIN DATABASE MODEL
class Setlistdb extends SqfEntityModelProvider {
  Setlistdb() {
    databaseName = setlistdb.databaseName;
    password = setlistdb.password;
    dbVersion = setlistdb.dbVersion;
    preSaveAction = setlistdb.preSaveAction;
    logFunction = setlistdb.logFunction;
    databaseTables = [
      TableSetlist.getInstance,
      TableSetlistTrack.getInstance,
      TableTrack.getInstance,
      TableTempo.getInstance,
    ];

    bundledDatabasePath = setlistdb
        .bundledDatabasePath; //'assets/sample.db'; // This value is optional. When bundledDatabasePath is empty then EntityBase creats a new database when initializing the database
    databasePath = setlistdb.databasePath;
  }
  Map<String, dynamic> getControllers() {
    final controllers = <String, dynamic>{};

    return controllers;
  }
}
// END DATABASE MODEL

// BEGIN ENTITIES
// region Setlist
class Setlist extends TableBase {
  Setlist(
      {this.row__id,
      this.description,
      this.row__sortOrder,
      this.date,
      this.location,
      this.setlistType}) {
    _setDefaultValues();
    softDeleteActivated = false;
  }
  Setlist.withFields(this.row__id, this.description, this.row__sortOrder,
      this.date, this.location, this.setlistType) {
    _setDefaultValues();
  }
  Setlist.withId(this.row__id, this.description, this.row__sortOrder, this.date,
      this.location, this.setlistType) {
    _setDefaultValues();
  }
  // fromMap v2.0
  Setlist.fromMap(Map<String, dynamic> o, {bool setDefaultValues = true}) {
    if (setDefaultValues) {
      _setDefaultValues();
    }
    row__id = o['row__id'].toString();
    if (o['description'] != null) {
      description = o['description'].toString();
    }
    if (o['row__sortOrder'] != null) {
      row__sortOrder = int.tryParse(o['row__sortOrder'].toString());
    }
    if (o['date'] != null) {
      date = int.tryParse(o['date'].toString()) != null
          ? DateTime.fromMillisecondsSinceEpoch(
              int.tryParse(o['date'].toString())!)
          : DateTime.tryParse(o['date'].toString());
    }
    if (o['location'] != null) {
      location = o['location'].toString();
    }
    if (o['setlistType'] != null) {
      setlistType = int.tryParse(o['setlistType'].toString());
    }

    isSaved = true;
  }
  // FIELDS (Setlist)
  String? row__id;
  String? description;
  int? row__sortOrder;
  DateTime? date;
  String? location;
  int? setlistType;
  bool? isSaved;
  // end FIELDS (Setlist)

// COLLECTIONS & VIRTUALS (Setlist)
  /// to load children of items to this field, use preload parameter. Ex: toList(preload:true) or toSingle(preload:true) or getById(preload:true)
  /// You can also specify this object into certain preload fields!. Ex: toList(preload:true, preloadFields:['plSetlistTracks', 'plField2'..]) or so on..
  List<SetlistTrack>? plSetlistTracks;

  /// get SetlistTrack(s) filtered by row__id=setlistId
  SetlistTrackFilterBuilder? getSetlistTracks(
      {List<String>? columnsToSelect, bool? getIsDeleted}) {
    if (row__id == null) {
      return null;
    }
    return SetlistTrack()
        .select(columnsToSelect: columnsToSelect, getIsDeleted: getIsDeleted)
        .setlistId
        .equals(row__id)
        .and;
  }

// END COLLECTIONS & VIRTUALS (Setlist)

  static const bool _softDeleteActivated = false;
  SetlistManager? __mnSetlist;

  SetlistManager get _mnSetlist {
    return __mnSetlist = __mnSetlist ?? SetlistManager();
  }

  // METHODS
  @override
  Map<String, dynamic> toMap(
      {bool forQuery = false, bool forJson = false, bool forView = false}) {
    final map = <String, dynamic>{};
    map['row__id'] = row__id;
    if (description != null || !forView) {
      map['description'] = description;
    }
    if (row__sortOrder != null || !forView) {
      map['row__sortOrder'] = row__sortOrder;
    }
    if (date != null) {
      map['date'] = forJson
          ? date!.toString()
          : forQuery
              ? date!.millisecondsSinceEpoch
              : date;
    } else if (date != null || !forView) {
      map['date'] = null;
    }
    if (location != null || !forView) {
      map['location'] = location;
    }
    if (setlistType != null || !forView) {
      map['setlistType'] = setlistType;
    }

    return map;
  }

  @override
  Future<Map<String, dynamic>> toMapWithChildren(
      [bool forQuery = false,
      bool forJson = false,
      bool forView = false]) async {
    final map = <String, dynamic>{};
    map['row__id'] = row__id;
    if (description != null || !forView) {
      map['description'] = description;
    }
    if (row__sortOrder != null || !forView) {
      map['row__sortOrder'] = row__sortOrder;
    }
    if (date != null) {
      map['date'] = forJson
          ? date!.toString()
          : forQuery
              ? date!.millisecondsSinceEpoch
              : date;
    } else if (date != null || !forView) {
      map['date'] = null;
    }
    if (location != null || !forView) {
      map['location'] = location;
    }
    if (setlistType != null || !forView) {
      map['setlistType'] = setlistType;
    }

// COLLECTIONS (Setlist)
    if (!forQuery) {
      map['SetlistTracks'] = await getSetlistTracks()!.toMapList();
    }
// END COLLECTIONS (Setlist)

    return map;
  }

  /// This method returns Json String [Setlist]
  @override
  String toJson() {
    return json.encode(toMap(forJson: true));
  }

  /// This method returns Json String [Setlist]
  @override
  Future<String> toJsonWithChilds() async {
    return json.encode(await toMapWithChildren(false, true));
  }

  @override
  List<dynamic> toArgs() {
    return [
      row__id,
      description,
      row__sortOrder,
      date != null ? date!.millisecondsSinceEpoch : null,
      location,
      setlistType
    ];
  }

  @override
  List<dynamic> toArgsWithIds() {
    return [
      row__id,
      description,
      row__sortOrder,
      date != null ? date!.millisecondsSinceEpoch : null,
      location,
      setlistType
    ];
  }

  static Future<List<Setlist>?> fromWebUrl(Uri uri,
      {Map<String, String>? headers}) async {
    try {
      final response = await http.get(uri, headers: headers);
      return await fromJson(response.body);
    } catch (e) {
      debugPrint(
          'SQFENTITY ERROR Setlist.fromWebUrl: ErrorMessage: ${e.toString()}');
      return null;
    }
  }

  Future<http.Response> postUrl(Uri uri, {Map<String, String>? headers}) {
    return http.post(uri, headers: headers, body: toJson());
  }

  static Future<List<Setlist>> fromJson(String jsonBody) async {
    final Iterable list = await json.decode(jsonBody) as Iterable;
    var objList = <Setlist>[];
    try {
      objList = list
          .map((setlist) => Setlist.fromMap(setlist as Map<String, dynamic>))
          .toList();
    } catch (e) {
      debugPrint(
          'SQFENTITY ERROR Setlist.fromJson: ErrorMessage: ${e.toString()}');
    }
    return objList;
  }

  static Future<List<Setlist>> fromMapList(List<dynamic> data,
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields,
      bool setDefaultValues = true}) async {
    final List<Setlist> objList = <Setlist>[];
    loadedFields = loadedFields ?? [];
    for (final map in data) {
      final obj = Setlist.fromMap(map as Map<String, dynamic>,
          setDefaultValues: setDefaultValues);
      // final List<String> _loadedFields = List<String>.from(loadedFields);

      // RELATIONSHIPS PRELOAD CHILD
      if (preload) {
        loadedFields = loadedFields ?? [];
        if (/*!_loadedfields!.contains('Setlist.plSetlistTracks') && */ (preloadFields ==
                null ||
            preloadFields.contains('plSetlistTracks'))) {
          /*_loadedfields!.add('Setlist.plSetlistTracks'); */ obj
                  .plSetlistTracks =
              obj.plSetlistTracks ??
                  await obj.getSetlistTracks()!.toList(
                      preload: preload,
                      preloadFields: preloadFields,
                      loadParents: false /*, loadedFields:_loadedFields*/);
        }
      } // END RELATIONSHIPS PRELOAD CHILD

      objList.add(obj);
    }
    return objList;
  }

  /// returns Setlist by ID if exist, otherwise returns null
  /// Primary Keys: String? row__id
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  /// ex: getById(preload:true) -> Loads all related objects
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  /// ex: getById(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  /// <returns>returns [Setlist] if exist, otherwise returns null
  Future<Setlist?> getById(String? row__id,
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    if (row__id == null) {
      return null;
    }
    Setlist? obj;
    final data = await _mnSetlist.getById([row__id]);
    if (data.length != 0) {
      obj = Setlist.fromMap(data[0] as Map<String, dynamic>);

      // RELATIONSHIPS PRELOAD CHILD
      if (preload) {
        loadedFields = loadedFields ?? [];
        if (/*!_loadedfields!.contains('Setlist.plSetlistTracks') && */ (preloadFields ==
                null ||
            preloadFields.contains('plSetlistTracks'))) {
          /*_loadedfields!.add('Setlist.plSetlistTracks'); */ obj
                  .plSetlistTracks =
              obj.plSetlistTracks ??
                  await obj.getSetlistTracks()!.toList(
                      preload: preload,
                      preloadFields: preloadFields,
                      loadParents: false /*, loadedFields:_loadedFields*/);
        }
      } // END RELATIONSHIPS PRELOAD CHILD
    } else {
      obj = null;
    }
    return obj;
  }

  /// Saves the (Setlist) object. If the Primary Key (row__id) field is null, returns Error.
  /// INSERTS (If not exist) OR REPLACES (If exist) data while Primary Key is not null.
  /// Call the saveAs() method if you do not want to save it when there is another row with the same row__id
  /// <returns>Returns BoolResult
  @override
  Future<BoolResult> save({bool ignoreBatch = true}) async {
    final result = BoolResult(success: false);
    try {
      await _mnSetlist.rawInsert(
          'INSERT ${isSaved! ? 'OR REPLACE' : ''} INTO Setlist (row__id, description, row__sortOrder, date, location, setlistType)  VALUES (?,?,?,?,?,?)',
          toArgsWithIds(),
          ignoreBatch);
      result.success = true;
      isSaved = true;
    } catch (e) {
      result.errorMessage = e.toString();
    }

    saveResult = result;
    return result;
  }

  /// saveAll method saves the sent List<Setlist> as a bulk in one transaction
  /// Returns a <List<BoolResult>>
  static Future<List<dynamic>> saveAll(List<Setlist> setlists,
      {bool? exclusive, bool? noResult, bool? continueOnError}) async {
    List<dynamic>? result = [];
    // If there is no open transaction, start one
    final isStartedBatch = await Setlistdb().batchStart();
    for (final obj in setlists) {
      await obj.save();
    }
    if (!isStartedBatch) {
      result = await Setlistdb().batchCommit(
          exclusive: exclusive,
          noResult: noResult,
          continueOnError: continueOnError);
    }
    return result!;
  }

  /// Updates if the record exists, otherwise adds a new row
  /// <returns>Returns 1
  @override
  Future<int?> upsert({bool ignoreBatch = true}) async {
    try {
      final result = await _mnSetlist.rawInsert(
          'INSERT OR REPLACE INTO Setlist (row__id, description, row__sortOrder, date, location, setlistType)  VALUES (?,?,?,?,?,?)',
          [
            row__id,
            description,
            row__sortOrder,
            date != null ? date!.millisecondsSinceEpoch : null,
            location,
            setlistType
          ],
          ignoreBatch);
      if (result! > 0) {
        saveResult = BoolResult(
            success: true,
            successMessage: 'Setlist row__id=$row__id updated successfully');
      } else {
        saveResult = BoolResult(
            success: false,
            errorMessage: 'Setlist row__id=$row__id did not update');
      }
      return 1;
    } catch (e) {
      saveResult = BoolResult(
          success: false,
          errorMessage: 'Setlist Save failed. Error: ${e.toString()}');
      return null;
    }
  }

  /// Deletes Setlist

  /// <returns>BoolResult res.success= true (Deleted), false (Could not be deleted)
  @override
  Future<BoolResult> delete([bool hardDelete = false]) async {
    debugPrint('SQFENTITIY: delete Setlist invoked (row__id=$row__id)');
    if (await SetlistTrack().select().setlistId.equals(row__id).and.toCount() >
        0) {
      return BoolResult(
          success: false,
          errorMessage:
              'SQFENTITY ERROR: The DELETE statement conflicted with the REFERENCE RELATIONSHIP (SetlistTrack.setlistId)');
    }
    if (!_softDeleteActivated || hardDelete) {
      return _mnSetlist.delete(
          QueryParams(whereString: 'row__id=?', whereArguments: [row__id]));
    } else {
      return _mnSetlist.updateBatch(
          QueryParams(whereString: 'row__id=?', whereArguments: [row__id]),
          {'isDeleted': 1});
    }
  }

  @override
  Future<BoolResult> recover([bool recoverChilds = true]) {
    // not implemented because:
    final msg =
        'set useSoftDeleting:true in the table definition of [Setlist] to use this feature';
    throw UnimplementedError(msg);
  }

  @override
  SetlistFilterBuilder select(
      {List<String>? columnsToSelect, bool? getIsDeleted}) {
    return SetlistFilterBuilder(this, getIsDeleted)
      ..qparams.selectColumns = columnsToSelect;
  }

  @override
  SetlistFilterBuilder distinct(
      {List<String>? columnsToSelect, bool? getIsDeleted}) {
    return SetlistFilterBuilder(this, getIsDeleted)
      ..qparams.selectColumns = columnsToSelect
      ..qparams.distinct = true;
  }

  void _setDefaultValues() {
    isSaved = false;
  }

  @override
  void rollbackPk() {
    if (isInsert == true) {
      row__id = null;
    }
  }

  // END METHODS
  // BEGIN CUSTOM CODE
  /*
      you can define customCode property of your SqfEntityTable constant. For example:
      const tablePerson = SqfEntityTable(
      tableName: 'person',
      primaryKeyName: 'id',
      primaryKeyType: PrimaryKeyType.integer_auto_incremental,
      fields: [
        SqfEntityField('firstName', DbType.text),
        SqfEntityField('lastName', DbType.text),
      ],
      customCode: '''
       String fullName()
       { 
         return '$firstName $lastName';
       }
      ''');
     */
  // END CUSTOM CODE
}
// endregion setlist

// region SetlistField
class SetlistField extends FilterBase {
  SetlistField(SetlistFilterBuilder setlistFB) : super(setlistFB);

  @override
  SetlistFilterBuilder equals(dynamic pValue) {
    return super.equals(pValue) as SetlistFilterBuilder;
  }

  @override
  SetlistFilterBuilder equalsOrNull(dynamic pValue) {
    return super.equalsOrNull(pValue) as SetlistFilterBuilder;
  }

  @override
  SetlistFilterBuilder isNull() {
    return super.isNull() as SetlistFilterBuilder;
  }

  @override
  SetlistFilterBuilder contains(dynamic pValue) {
    return super.contains(pValue) as SetlistFilterBuilder;
  }

  @override
  SetlistFilterBuilder startsWith(dynamic pValue) {
    return super.startsWith(pValue) as SetlistFilterBuilder;
  }

  @override
  SetlistFilterBuilder endsWith(dynamic pValue) {
    return super.endsWith(pValue) as SetlistFilterBuilder;
  }

  @override
  SetlistFilterBuilder between(dynamic pFirst, dynamic pLast) {
    return super.between(pFirst, pLast) as SetlistFilterBuilder;
  }

  @override
  SetlistFilterBuilder greaterThan(dynamic pValue) {
    return super.greaterThan(pValue) as SetlistFilterBuilder;
  }

  @override
  SetlistFilterBuilder lessThan(dynamic pValue) {
    return super.lessThan(pValue) as SetlistFilterBuilder;
  }

  @override
  SetlistFilterBuilder greaterThanOrEquals(dynamic pValue) {
    return super.greaterThanOrEquals(pValue) as SetlistFilterBuilder;
  }

  @override
  SetlistFilterBuilder lessThanOrEquals(dynamic pValue) {
    return super.lessThanOrEquals(pValue) as SetlistFilterBuilder;
  }

  @override
  SetlistFilterBuilder inValues(dynamic pValue) {
    return super.inValues(pValue) as SetlistFilterBuilder;
  }

  @override
  SetlistField get not {
    return super.not as SetlistField;
  }
}
// endregion SetlistField

// region SetlistFilterBuilder
class SetlistFilterBuilder extends ConjunctionBase {
  SetlistFilterBuilder(Setlist obj, bool? getIsDeleted)
      : super(obj, getIsDeleted) {
    _mnSetlist = obj._mnSetlist;
    _softDeleteActivated = obj.softDeleteActivated;
  }

  bool _softDeleteActivated = false;
  SetlistManager? _mnSetlist;

  /// put the sql keyword 'AND'
  @override
  SetlistFilterBuilder get and {
    super.and;
    return this;
  }

  /// put the sql keyword 'OR'
  @override
  SetlistFilterBuilder get or {
    super.or;
    return this;
  }

  /// open parentheses
  @override
  SetlistFilterBuilder get startBlock {
    super.startBlock;
    return this;
  }

  /// String whereCriteria, write raw query without 'where' keyword. Like this: 'field1 like 'test%' and field2 = 3'
  @override
  SetlistFilterBuilder where(String? whereCriteria, {dynamic parameterValue}) {
    super.where(whereCriteria, parameterValue: parameterValue);
    return this;
  }

  /// page = page number,
  /// pagesize = row(s) per page
  @override
  SetlistFilterBuilder page(int page, int pagesize) {
    super.page(page, pagesize);
    return this;
  }

  /// int count = LIMIT
  @override
  SetlistFilterBuilder top(int count) {
    super.top(count);
    return this;
  }

  /// close parentheses
  @override
  SetlistFilterBuilder get endBlock {
    super.endBlock;
    return this;
  }

  /// argFields might be String or List<String>.
  /// Example 1: argFields='name, date'
  /// Example 2: argFields = ['name', 'date']
  @override
  SetlistFilterBuilder orderBy(dynamic argFields) {
    super.orderBy(argFields);
    return this;
  }

  /// argFields might be String or List<String>.
  /// Example 1: argFields='field1, field2'
  /// Example 2: argFields = ['field1', 'field2']
  @override
  SetlistFilterBuilder orderByDesc(dynamic argFields) {
    super.orderByDesc(argFields);
    return this;
  }

  /// argFields might be String or List<String>.
  /// Example 1: argFields='field1, field2'
  /// Example 2: argFields = ['field1', 'field2']
  @override
  SetlistFilterBuilder groupBy(dynamic argFields) {
    super.groupBy(argFields);
    return this;
  }

  /// argFields might be String or List<String>.
  /// Example 1: argFields='name, date'
  /// Example 2: argFields = ['name', 'date']
  @override
  SetlistFilterBuilder having(dynamic argFields) {
    super.having(argFields);
    return this;
  }

  SetlistField _setField(SetlistField? field, String colName, DbType dbtype) {
    return SetlistField(this)
      ..param = DbParameter(
          dbType: dbtype, columnName: colName, wStartBlock: openedBlock);
  }

  SetlistField? _row__id;
  SetlistField get row__id {
    return _row__id = _setField(_row__id, 'row__id', DbType.integer);
  }

  SetlistField? _description;
  SetlistField get description {
    return _description = _setField(_description, 'description', DbType.text);
  }

  SetlistField? _row__sortOrder;
  SetlistField get row__sortOrder {
    return _row__sortOrder =
        _setField(_row__sortOrder, 'row__sortOrder', DbType.integer);
  }

  SetlistField? _date;
  SetlistField get date {
    return _date = _setField(_date, 'date', DbType.datetime);
  }

  SetlistField? _location;
  SetlistField get location {
    return _location = _setField(_location, 'location', DbType.text);
  }

  SetlistField? _setlistType;
  SetlistField get setlistType {
    return _setlistType =
        _setField(_setlistType, 'setlistType', DbType.integer);
  }

  /// Deletes List<Setlist> bulk by query
  ///
  /// <returns>BoolResult res.success= true (Deleted), false (Could not be deleted)
  @override
  Future<BoolResult> delete([bool hardDelete = false]) async {
    buildParameters();
    var r = BoolResult(success: false);
    // Check sub records where in (SetlistTrack) according to DeleteRule.NO_ACTION

    final idListSetlistTrackBYsetlistId = toListPrimaryKeySQL(false);
    final resSetlistTrackBYsetlistId = await SetlistTrack()
        .select()
        .where('setlistId IN (${idListSetlistTrackBYsetlistId['sql']})',
            parameterValue: idListSetlistTrackBYsetlistId['args'])
        .toCount();
    if (resSetlistTrackBYsetlistId > 0) {
      return BoolResult(
          success: false,
          errorMessage:
              'SQFENTITY ERROR: The DELETE statement conflicted with the REFERENCE RELATIONSHIP (SetlistTrack.setlistId)');
    }

    if (_softDeleteActivated && !hardDelete) {
      r = await _mnSetlist!.updateBatch(qparams, {'isDeleted': 1});
    } else {
      r = await _mnSetlist!.delete(qparams);
    }
    return r;
  }

  /// using:
  /// update({'fieldName': Value})
  /// fieldName must be String. Value is dynamic, it can be any of the (int, bool, String.. )
  @override
  Future<BoolResult> update(Map<String, dynamic> values) {
    buildParameters();
    if (qparams.limit! > 0 || qparams.offset! > 0) {
      qparams.whereString =
          'row__id IN (SELECT row__id from Setlist ${qparams.whereString!.isNotEmpty ? 'WHERE ${qparams.whereString}' : ''}${qparams.limit! > 0 ? ' LIMIT ${qparams.limit}' : ''}${qparams.offset! > 0 ? ' OFFSET ${qparams.offset}' : ''})';
    }
    return _mnSetlist!.updateBatch(qparams, values);
  }

  /// This method always returns [Setlist] Obj if exist, otherwise returns null
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  /// ex: toSingle(preload:true) -> Loads all related objects
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  /// ex: toSingle(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  /// <returns> Setlist?
  @override
  Future<Setlist?> toSingle(
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    buildParameters(pSize: 1);
    final objFuture = _mnSetlist!.toList(qparams);
    final data = await objFuture;
    Setlist? obj;
    if (data.isNotEmpty) {
      obj = Setlist.fromMap(data[0] as Map<String, dynamic>);

      // RELATIONSHIPS PRELOAD CHILD
      if (preload) {
        loadedFields = loadedFields ?? [];
        if (/*!_loadedfields!.contains('Setlist.plSetlistTracks') && */ (preloadFields ==
                null ||
            preloadFields.contains('plSetlistTracks'))) {
          /*_loadedfields!.add('Setlist.plSetlistTracks'); */ obj
                  .plSetlistTracks =
              obj.plSetlistTracks ??
                  await obj.getSetlistTracks()!.toList(
                      preload: preload,
                      preloadFields: preloadFields,
                      loadParents: false /*, loadedFields:_loadedFields*/);
        }
      } // END RELATIONSHIPS PRELOAD CHILD
    } else {
      obj = null;
    }
    return obj;
  }

  /// This method always returns [Setlist]
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  /// ex: toSingle(preload:true) -> Loads all related objects
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  /// ex: toSingle(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  /// <returns> Setlist?
  @override
  Future<Setlist> toSingleOrDefault(
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    return await toSingle(
            preload: preload,
            preloadFields: preloadFields,
            loadParents: loadParents,
            loadedFields: loadedFields) ??
        Setlist();
  }

  /// This method returns int. [Setlist]
  /// <returns>int
  @override
  Future<int> toCount([VoidCallback Function(int c)? setlistCount]) async {
    buildParameters();
    qparams.selectColumns = ['COUNT(1) AS CNT'];
    final setlistsFuture = await _mnSetlist!.toList(qparams);
    final int count = setlistsFuture[0]['CNT'] as int;
    if (setlistCount != null) {
      setlistCount(count);
    }
    return count;
  }

  /// This method returns List<Setlist> [Setlist]
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  /// ex: toList(preload:true) -> Loads all related objects
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  /// ex: toList(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  /// <returns>List<Setlist>
  @override
  Future<List<Setlist>> toList(
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    final data = await toMapList();
    final List<Setlist> setlistsData = await Setlist.fromMapList(data,
        preload: preload,
        preloadFields: preloadFields,
        loadParents: loadParents,
        loadedFields: loadedFields,
        setDefaultValues: qparams.selectColumns == null);
    return setlistsData;
  }

  /// This method returns Json String [Setlist]
  @override
  Future<String> toJson() async {
    final list = <dynamic>[];
    final data = await toList();
    for (var o in data) {
      list.add(o.toMap(forJson: true));
    }
    return json.encode(list);
  }

  /// This method returns Json String. [Setlist]
  @override
  Future<String> toJsonWithChilds() async {
    final list = <dynamic>[];
    final data = await toList();
    for (var o in data) {
      list.add(await o.toMapWithChildren(false, true));
    }
    return json.encode(list);
  }

  /// This method returns List<dynamic>. [Setlist]
  /// <returns>List<dynamic>
  @override
  Future<List<dynamic>> toMapList() async {
    buildParameters();
    return await _mnSetlist!.toList(qparams);
  }

  /// This method returns Primary Key List SQL and Parameters retVal = Map<String,dynamic>. [Setlist]
  /// retVal['sql'] = SQL statement string, retVal['args'] = whereArguments List<dynamic>;
  /// <returns>List<String>
  @override
  Map<String, dynamic> toListPrimaryKeySQL([bool buildParams = true]) {
    final Map<String, dynamic> _retVal = <String, dynamic>{};
    if (buildParams) {
      buildParameters();
    }
    _retVal['sql'] =
        'SELECT `row__id` FROM Setlist WHERE ${qparams.whereString}';
    _retVal['args'] = qparams.whereArguments;
    return _retVal;
  }

  /// This method returns Primary Key List<String>.
  /// <returns>List<String>
  @override
  Future<List<String>> toListPrimaryKey([bool buildParams = true]) async {
    if (buildParams) {
      buildParameters();
    }
    final List<String> row__idData = <String>[];
    qparams.selectColumns = ['row__id'];
    final row__idFuture = await _mnSetlist!.toList(qparams);

    final int count = row__idFuture.length;
    for (int i = 0; i < count; i++) {
      row__idData.add(row__idFuture[i]['row__id'] as String);
    }
    return row__idData;
  }

  /// Returns List<dynamic> for selected columns. Use this method for 'groupBy' with min,max,avg..  [Setlist]
  /// Sample usage: (see EXAMPLE 4.2 at https://github.com/hhtokpinar/sqfEntity#group-by)
  @override
  Future<List<dynamic>> toListObject() async {
    buildParameters();

    final objectFuture = _mnSetlist!.toList(qparams);

    final List<dynamic> objectsData = <dynamic>[];
    final data = await objectFuture;
    final int count = data.length;
    for (int i = 0; i < count; i++) {
      objectsData.add(data[i]);
    }
    return objectsData;
  }

  /// Returns List<String> for selected first column
  /// Sample usage: await Setlist.select(columnsToSelect: ['columnName']).toListString()
  @override
  Future<List<String>> toListString(
      [VoidCallback Function(List<String> o)? listString]) async {
    buildParameters();

    final objectFuture = _mnSetlist!.toList(qparams);

    final List<String> objectsData = <String>[];
    final data = await objectFuture;
    final int count = data.length;
    for (int i = 0; i < count; i++) {
      objectsData.add(data[i][qparams.selectColumns![0]].toString());
    }
    if (listString != null) {
      listString(objectsData);
    }
    return objectsData;
  }
}
// endregion SetlistFilterBuilder

// region SetlistFields
class SetlistFields {
  static TableField? _fRow__id;
  static TableField get row__id {
    return _fRow__id =
        _fRow__id ?? SqlSyntax.setField(_fRow__id, 'row__id', DbType.integer);
  }

  static TableField? _fDescription;
  static TableField get description {
    return _fDescription = _fDescription ??
        SqlSyntax.setField(_fDescription, 'description', DbType.text);
  }

  static TableField? _fRow__sortOrder;
  static TableField get row__sortOrder {
    return _fRow__sortOrder = _fRow__sortOrder ??
        SqlSyntax.setField(_fRow__sortOrder, 'row__sortOrder', DbType.integer);
  }

  static TableField? _fDate;
  static TableField get date {
    return _fDate =
        _fDate ?? SqlSyntax.setField(_fDate, 'date', DbType.datetime);
  }

  static TableField? _fLocation;
  static TableField get location {
    return _fLocation =
        _fLocation ?? SqlSyntax.setField(_fLocation, 'location', DbType.text);
  }

  static TableField? _fSetlistType;
  static TableField get setlistType {
    return _fSetlistType = _fSetlistType ??
        SqlSyntax.setField(_fSetlistType, 'setlistType', DbType.integer);
  }
}
// endregion SetlistFields

//region SetlistManager
class SetlistManager extends SqfEntityProvider {
  SetlistManager()
      : super(Setlistdb(),
            tableName: _tableName,
            primaryKeyList: _primaryKeyList,
            whereStr: _whereStr);
  static const String _tableName = 'Setlist';
  static const List<String> _primaryKeyList = ['row__id'];
  static const String _whereStr = 'row__id=?';
}

//endregion SetlistManager
// region SetlistTrack
class SetlistTrack extends TableBase {
  SetlistTrack(
      {this.row__id,
      this.row__sortOrder,
      this.notes,
      this.setlistId,
      this.setlistType,
      this.trackId}) {
    _setDefaultValues();
    softDeleteActivated = false;
  }
  SetlistTrack.withFields(this.row__id, this.row__sortOrder, this.notes,
      this.setlistId, this.setlistType, this.trackId) {
    _setDefaultValues();
  }
  SetlistTrack.withId(this.row__id, this.row__sortOrder, this.notes,
      this.setlistId, this.setlistType, this.trackId) {
    _setDefaultValues();
  }
  // fromMap v2.0
  SetlistTrack.fromMap(Map<String, dynamic> o, {bool setDefaultValues = true}) {
    if (setDefaultValues) {
      _setDefaultValues();
    }
    row__id = o['row__id'].toString();
    if (o['row__sortOrder'] != null) {
      row__sortOrder = int.tryParse(o['row__sortOrder'].toString());
    }
    if (o['notes'] != null) {
      notes = o['notes'].toString();
    }
    setlistId = o['setlistId'].toString();

    if (o['setlistType'] != null) {
      setlistType = int.tryParse(o['setlistType'].toString());
    }
    trackId = o['trackId'].toString();

    // RELATIONSHIPS FromMAP
    plSetlist = o['setlist'] != null
        ? Setlist.fromMap(o['setlist'] as Map<String, dynamic>)
        : null;
    plTrack = o['track'] != null
        ? Track.fromMap(o['track'] as Map<String, dynamic>)
        : null;
    // END RELATIONSHIPS FromMAP

    isSaved = true;
  }
  // FIELDS (SetlistTrack)
  String? row__id;
  int? row__sortOrder;
  String? notes;
  String? setlistId;
  int? setlistType;
  String? trackId;
  bool? isSaved;
  // end FIELDS (SetlistTrack)

// RELATIONSHIPS (SetlistTrack)
  /// to load parent of items to this field, use preload parameter ex: toList(preload:true) or toSingle(preload:true) or getById(preload:true)
  /// You can also specify this object into certain preload fields!. Ex: toList(preload:true, preloadFields:['plSetlist', 'plField2'..]) or so on..
  Setlist? plSetlist;

  /// get Setlist By SetlistId
  Future<Setlist?> getSetlist(
      {bool loadParents = false, List<String>? loadedFields}) async {
    final _obj = await Setlist().getById(setlistId,
        loadParents: loadParents, loadedFields: loadedFields);
    return _obj;
  }

  /// to load parent of items to this field, use preload parameter ex: toList(preload:true) or toSingle(preload:true) or getById(preload:true)
  /// You can also specify this object into certain preload fields!. Ex: toList(preload:true, preloadFields:['plTrack', 'plField2'..]) or so on..
  Track? plTrack;

  /// get Track By TrackId
  Future<Track?> getTrack(
      {bool loadParents = false, List<String>? loadedFields}) async {
    final _obj = await Track()
        .getById(trackId, loadParents: loadParents, loadedFields: loadedFields);
    return _obj;
  }
  // END RELATIONSHIPS (SetlistTrack)

  static const bool _softDeleteActivated = false;
  SetlistTrackManager? __mnSetlistTrack;

  SetlistTrackManager get _mnSetlistTrack {
    return __mnSetlistTrack = __mnSetlistTrack ?? SetlistTrackManager();
  }

  // METHODS
  @override
  Map<String, dynamic> toMap(
      {bool forQuery = false, bool forJson = false, bool forView = false}) {
    final map = <String, dynamic>{};
    map['row__id'] = row__id;
    if (row__sortOrder != null || !forView) {
      map['row__sortOrder'] = row__sortOrder;
    }
    if (notes != null || !forView) {
      map['notes'] = notes;
    }
    if (setlistId != null) {
      map['setlistId'] = forView
          ? plSetlist == null
              ? setlistId
              : plSetlist!.description
          : setlistId;
    } else if (setlistId != null || !forView) {
      map['setlistId'] = null;
    }
    if (setlistType != null || !forView) {
      map['setlistType'] = setlistType;
    }
    if (trackId != null) {
      map['trackId'] = forView
          ? plTrack == null
              ? trackId
              : plTrack!.title
          : trackId;
    } else if (trackId != null || !forView) {
      map['trackId'] = null;
    }

    return map;
  }

  @override
  Future<Map<String, dynamic>> toMapWithChildren(
      [bool forQuery = false,
      bool forJson = false,
      bool forView = false]) async {
    final map = <String, dynamic>{};
    map['row__id'] = row__id;
    if (row__sortOrder != null || !forView) {
      map['row__sortOrder'] = row__sortOrder;
    }
    if (notes != null || !forView) {
      map['notes'] = notes;
    }
    if (setlistId != null) {
      map['setlistId'] = forView
          ? plSetlist == null
              ? setlistId
              : plSetlist!.description
          : setlistId;
    } else if (setlistId != null || !forView) {
      map['setlistId'] = null;
    }
    if (setlistType != null || !forView) {
      map['setlistType'] = setlistType;
    }
    if (trackId != null) {
      map['trackId'] = forView
          ? plTrack == null
              ? trackId
              : plTrack!.title
          : trackId;
    } else if (trackId != null || !forView) {
      map['trackId'] = null;
    }

    return map;
  }

  /// This method returns Json String [SetlistTrack]
  @override
  String toJson() {
    return json.encode(toMap(forJson: true));
  }

  /// This method returns Json String [SetlistTrack]
  @override
  Future<String> toJsonWithChilds() async {
    return json.encode(await toMapWithChildren(false, true));
  }

  @override
  List<dynamic> toArgs() {
    return [row__id, row__sortOrder, notes, setlistId, setlistType, trackId];
  }

  @override
  List<dynamic> toArgsWithIds() {
    return [row__id, row__sortOrder, notes, setlistId, setlistType, trackId];
  }

  static Future<List<SetlistTrack>?> fromWebUrl(Uri uri,
      {Map<String, String>? headers}) async {
    try {
      final response = await http.get(uri, headers: headers);
      return await fromJson(response.body);
    } catch (e) {
      debugPrint(
          'SQFENTITY ERROR SetlistTrack.fromWebUrl: ErrorMessage: ${e.toString()}');
      return null;
    }
  }

  Future<http.Response> postUrl(Uri uri, {Map<String, String>? headers}) {
    return http.post(uri, headers: headers, body: toJson());
  }

  static Future<List<SetlistTrack>> fromJson(String jsonBody) async {
    final Iterable list = await json.decode(jsonBody) as Iterable;
    var objList = <SetlistTrack>[];
    try {
      objList = list
          .map((setlisttrack) =>
              SetlistTrack.fromMap(setlisttrack as Map<String, dynamic>))
          .toList();
    } catch (e) {
      debugPrint(
          'SQFENTITY ERROR SetlistTrack.fromJson: ErrorMessage: ${e.toString()}');
    }
    return objList;
  }

  static Future<List<SetlistTrack>> fromMapList(List<dynamic> data,
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields,
      bool setDefaultValues = true}) async {
    final List<SetlistTrack> objList = <SetlistTrack>[];
    loadedFields = loadedFields ?? [];
    for (final map in data) {
      final obj = SetlistTrack.fromMap(map as Map<String, dynamic>,
          setDefaultValues: setDefaultValues);
      // final List<String> _loadedFields = List<String>.from(loadedFields);

      // RELATIONSHIPS PRELOAD
      if (preload || loadParents) {
        loadedFields = loadedFields ?? [];
        if ((preloadFields == null ||
            loadParents ||
            preloadFields.contains('plSetlist'))) {
          obj.plSetlist =
              obj.plSetlist ?? await obj.getSetlist(loadParents: loadParents);
        }
        if ((preloadFields == null ||
            loadParents ||
            preloadFields.contains('plTrack'))) {
          obj.plTrack =
              obj.plTrack ?? await obj.getTrack(loadParents: loadParents);
        }
      } // END RELATIONSHIPS PRELOAD

      objList.add(obj);
    }
    return objList;
  }

  /// returns SetlistTrack by ID if exist, otherwise returns null
  /// Primary Keys: String? row__id
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  /// ex: getById(preload:true) -> Loads all related objects
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  /// ex: getById(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  /// <returns>returns [SetlistTrack] if exist, otherwise returns null
  Future<SetlistTrack?> getById(String? row__id,
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    if (row__id == null) {
      return null;
    }
    SetlistTrack? obj;
    final data = await _mnSetlistTrack.getById([row__id]);
    if (data.length != 0) {
      obj = SetlistTrack.fromMap(data[0] as Map<String, dynamic>);

      // RELATIONSHIPS PRELOAD
      if (preload || loadParents) {
        loadedFields = loadedFields ?? [];
        if ((preloadFields == null ||
            loadParents ||
            preloadFields.contains('plSetlist'))) {
          obj.plSetlist =
              obj.plSetlist ?? await obj.getSetlist(loadParents: loadParents);
        }
        if ((preloadFields == null ||
            loadParents ||
            preloadFields.contains('plTrack'))) {
          obj.plTrack =
              obj.plTrack ?? await obj.getTrack(loadParents: loadParents);
        }
      } // END RELATIONSHIPS PRELOAD
    } else {
      obj = null;
    }
    return obj;
  }

  /// Saves the (SetlistTrack) object. If the Primary Key (row__id) field is null, returns Error.
  /// INSERTS (If not exist) OR REPLACES (If exist) data while Primary Key is not null.
  /// Call the saveAs() method if you do not want to save it when there is another row with the same row__id
  /// <returns>Returns BoolResult
  @override
  Future<BoolResult> save({bool ignoreBatch = true}) async {
    final result = BoolResult(success: false);
    try {
      await _mnSetlistTrack.rawInsert(
          'INSERT ${isSaved! ? 'OR REPLACE' : ''} INTO SetlistTrack (row__id, row__sortOrder, notes, setlistId, setlistType, trackId)  VALUES (?,?,?,?,?,?)',
          toArgsWithIds(),
          ignoreBatch);
      result.success = true;
      isSaved = true;
    } catch (e) {
      result.errorMessage = e.toString();
    }

    saveResult = result;
    return result;
  }

  /// saveAll method saves the sent List<SetlistTrack> as a bulk in one transaction
  /// Returns a <List<BoolResult>>
  static Future<List<dynamic>> saveAll(List<SetlistTrack> setlisttracks,
      {bool? exclusive, bool? noResult, bool? continueOnError}) async {
    List<dynamic>? result = [];
    // If there is no open transaction, start one
    final isStartedBatch = await Setlistdb().batchStart();
    for (final obj in setlisttracks) {
      await obj.save();
    }
    if (!isStartedBatch) {
      result = await Setlistdb().batchCommit(
          exclusive: exclusive,
          noResult: noResult,
          continueOnError: continueOnError);
    }
    return result!;
  }

  /// Updates if the record exists, otherwise adds a new row
  /// <returns>Returns 1
  @override
  Future<int?> upsert({bool ignoreBatch = true}) async {
    try {
      final result = await _mnSetlistTrack.rawInsert(
          'INSERT OR REPLACE INTO SetlistTrack (row__id, row__sortOrder, notes, setlistId, setlistType, trackId)  VALUES (?,?,?,?,?,?)',
          [row__id, row__sortOrder, notes, setlistId, setlistType, trackId],
          ignoreBatch);
      if (result! > 0) {
        saveResult = BoolResult(
            success: true,
            successMessage:
                'SetlistTrack row__id=$row__id updated successfully');
      } else {
        saveResult = BoolResult(
            success: false,
            errorMessage: 'SetlistTrack row__id=$row__id did not update');
      }
      return 1;
    } catch (e) {
      saveResult = BoolResult(
          success: false,
          errorMessage: 'SetlistTrack Save failed. Error: ${e.toString()}');
      return null;
    }
  }

  /// Deletes SetlistTrack

  /// <returns>BoolResult res.success= true (Deleted), false (Could not be deleted)
  @override
  Future<BoolResult> delete([bool hardDelete = false]) async {
    debugPrint('SQFENTITIY: delete SetlistTrack invoked (row__id=$row__id)');
    if (!_softDeleteActivated || hardDelete) {
      return _mnSetlistTrack.delete(
          QueryParams(whereString: 'row__id=?', whereArguments: [row__id]));
    } else {
      return _mnSetlistTrack.updateBatch(
          QueryParams(whereString: 'row__id=?', whereArguments: [row__id]),
          {'isDeleted': 1});
    }
  }

  @override
  Future<BoolResult> recover([bool recoverChilds = true]) {
    // not implemented because:
    final msg =
        'set useSoftDeleting:true in the table definition of [SetlistTrack] to use this feature';
    throw UnimplementedError(msg);
  }

  @override
  SetlistTrackFilterBuilder select(
      {List<String>? columnsToSelect, bool? getIsDeleted}) {
    return SetlistTrackFilterBuilder(this, getIsDeleted)
      ..qparams.selectColumns = columnsToSelect;
  }

  @override
  SetlistTrackFilterBuilder distinct(
      {List<String>? columnsToSelect, bool? getIsDeleted}) {
    return SetlistTrackFilterBuilder(this, getIsDeleted)
      ..qparams.selectColumns = columnsToSelect
      ..qparams.distinct = true;
  }

  void _setDefaultValues() {
    isSaved = false;
  }

  @override
  void rollbackPk() {
    if (isInsert == true) {
      row__id = null;
    }
  }

  // END METHODS
  // BEGIN CUSTOM CODE
  /*
      you can define customCode property of your SqfEntityTable constant. For example:
      const tablePerson = SqfEntityTable(
      tableName: 'person',
      primaryKeyName: 'id',
      primaryKeyType: PrimaryKeyType.integer_auto_incremental,
      fields: [
        SqfEntityField('firstName', DbType.text),
        SqfEntityField('lastName', DbType.text),
      ],
      customCode: '''
       String fullName()
       { 
         return '$firstName $lastName';
       }
      ''');
     */
  // END CUSTOM CODE
}
// endregion setlisttrack

// region SetlistTrackField
class SetlistTrackField extends FilterBase {
  SetlistTrackField(SetlistTrackFilterBuilder setlisttrackFB)
      : super(setlisttrackFB);

  @override
  SetlistTrackFilterBuilder equals(dynamic pValue) {
    return super.equals(pValue) as SetlistTrackFilterBuilder;
  }

  @override
  SetlistTrackFilterBuilder equalsOrNull(dynamic pValue) {
    return super.equalsOrNull(pValue) as SetlistTrackFilterBuilder;
  }

  @override
  SetlistTrackFilterBuilder isNull() {
    return super.isNull() as SetlistTrackFilterBuilder;
  }

  @override
  SetlistTrackFilterBuilder contains(dynamic pValue) {
    return super.contains(pValue) as SetlistTrackFilterBuilder;
  }

  @override
  SetlistTrackFilterBuilder startsWith(dynamic pValue) {
    return super.startsWith(pValue) as SetlistTrackFilterBuilder;
  }

  @override
  SetlistTrackFilterBuilder endsWith(dynamic pValue) {
    return super.endsWith(pValue) as SetlistTrackFilterBuilder;
  }

  @override
  SetlistTrackFilterBuilder between(dynamic pFirst, dynamic pLast) {
    return super.between(pFirst, pLast) as SetlistTrackFilterBuilder;
  }

  @override
  SetlistTrackFilterBuilder greaterThan(dynamic pValue) {
    return super.greaterThan(pValue) as SetlistTrackFilterBuilder;
  }

  @override
  SetlistTrackFilterBuilder lessThan(dynamic pValue) {
    return super.lessThan(pValue) as SetlistTrackFilterBuilder;
  }

  @override
  SetlistTrackFilterBuilder greaterThanOrEquals(dynamic pValue) {
    return super.greaterThanOrEquals(pValue) as SetlistTrackFilterBuilder;
  }

  @override
  SetlistTrackFilterBuilder lessThanOrEquals(dynamic pValue) {
    return super.lessThanOrEquals(pValue) as SetlistTrackFilterBuilder;
  }

  @override
  SetlistTrackFilterBuilder inValues(dynamic pValue) {
    return super.inValues(pValue) as SetlistTrackFilterBuilder;
  }

  @override
  SetlistTrackField get not {
    return super.not as SetlistTrackField;
  }
}
// endregion SetlistTrackField

// region SetlistTrackFilterBuilder
class SetlistTrackFilterBuilder extends ConjunctionBase {
  SetlistTrackFilterBuilder(SetlistTrack obj, bool? getIsDeleted)
      : super(obj, getIsDeleted) {
    _mnSetlistTrack = obj._mnSetlistTrack;
    _softDeleteActivated = obj.softDeleteActivated;
  }

  bool _softDeleteActivated = false;
  SetlistTrackManager? _mnSetlistTrack;

  /// put the sql keyword 'AND'
  @override
  SetlistTrackFilterBuilder get and {
    super.and;
    return this;
  }

  /// put the sql keyword 'OR'
  @override
  SetlistTrackFilterBuilder get or {
    super.or;
    return this;
  }

  /// open parentheses
  @override
  SetlistTrackFilterBuilder get startBlock {
    super.startBlock;
    return this;
  }

  /// String whereCriteria, write raw query without 'where' keyword. Like this: 'field1 like 'test%' and field2 = 3'
  @override
  SetlistTrackFilterBuilder where(String? whereCriteria,
      {dynamic parameterValue}) {
    super.where(whereCriteria, parameterValue: parameterValue);
    return this;
  }

  /// page = page number,
  /// pagesize = row(s) per page
  @override
  SetlistTrackFilterBuilder page(int page, int pagesize) {
    super.page(page, pagesize);
    return this;
  }

  /// int count = LIMIT
  @override
  SetlistTrackFilterBuilder top(int count) {
    super.top(count);
    return this;
  }

  /// close parentheses
  @override
  SetlistTrackFilterBuilder get endBlock {
    super.endBlock;
    return this;
  }

  /// argFields might be String or List<String>.
  /// Example 1: argFields='name, date'
  /// Example 2: argFields = ['name', 'date']
  @override
  SetlistTrackFilterBuilder orderBy(dynamic argFields) {
    super.orderBy(argFields);
    return this;
  }

  /// argFields might be String or List<String>.
  /// Example 1: argFields='field1, field2'
  /// Example 2: argFields = ['field1', 'field2']
  @override
  SetlistTrackFilterBuilder orderByDesc(dynamic argFields) {
    super.orderByDesc(argFields);
    return this;
  }

  /// argFields might be String or List<String>.
  /// Example 1: argFields='field1, field2'
  /// Example 2: argFields = ['field1', 'field2']
  @override
  SetlistTrackFilterBuilder groupBy(dynamic argFields) {
    super.groupBy(argFields);
    return this;
  }

  /// argFields might be String or List<String>.
  /// Example 1: argFields='name, date'
  /// Example 2: argFields = ['name', 'date']
  @override
  SetlistTrackFilterBuilder having(dynamic argFields) {
    super.having(argFields);
    return this;
  }

  SetlistTrackField _setField(
      SetlistTrackField? field, String colName, DbType dbtype) {
    return SetlistTrackField(this)
      ..param = DbParameter(
          dbType: dbtype, columnName: colName, wStartBlock: openedBlock);
  }

  SetlistTrackField? _row__id;
  SetlistTrackField get row__id {
    return _row__id = _setField(_row__id, 'row__id', DbType.integer);
  }

  SetlistTrackField? _row__sortOrder;
  SetlistTrackField get row__sortOrder {
    return _row__sortOrder =
        _setField(_row__sortOrder, 'row__sortOrder', DbType.integer);
  }

  SetlistTrackField? _notes;
  SetlistTrackField get notes {
    return _notes = _setField(_notes, 'notes', DbType.text);
  }

  SetlistTrackField? _setlistId;
  SetlistTrackField get setlistId {
    return _setlistId = _setField(_setlistId, 'setlistId', DbType.text);
  }

  SetlistTrackField? _setlistType;
  SetlistTrackField get setlistType {
    return _setlistType =
        _setField(_setlistType, 'setlistType', DbType.integer);
  }

  SetlistTrackField? _trackId;
  SetlistTrackField get trackId {
    return _trackId = _setField(_trackId, 'trackId', DbType.text);
  }

  /// Deletes List<SetlistTrack> bulk by query
  ///
  /// <returns>BoolResult res.success= true (Deleted), false (Could not be deleted)
  @override
  Future<BoolResult> delete([bool hardDelete = false]) async {
    buildParameters();
    var r = BoolResult(success: false);

    if (_softDeleteActivated && !hardDelete) {
      r = await _mnSetlistTrack!.updateBatch(qparams, {'isDeleted': 1});
    } else {
      r = await _mnSetlistTrack!.delete(qparams);
    }
    return r;
  }

  /// using:
  /// update({'fieldName': Value})
  /// fieldName must be String. Value is dynamic, it can be any of the (int, bool, String.. )
  @override
  Future<BoolResult> update(Map<String, dynamic> values) {
    buildParameters();
    if (qparams.limit! > 0 || qparams.offset! > 0) {
      qparams.whereString =
          'row__id IN (SELECT row__id from SetlistTrack ${qparams.whereString!.isNotEmpty ? 'WHERE ${qparams.whereString}' : ''}${qparams.limit! > 0 ? ' LIMIT ${qparams.limit}' : ''}${qparams.offset! > 0 ? ' OFFSET ${qparams.offset}' : ''})';
    }
    return _mnSetlistTrack!.updateBatch(qparams, values);
  }

  /// This method always returns [SetlistTrack] Obj if exist, otherwise returns null
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  /// ex: toSingle(preload:true) -> Loads all related objects
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  /// ex: toSingle(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  /// <returns> SetlistTrack?
  @override
  Future<SetlistTrack?> toSingle(
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    buildParameters(pSize: 1);
    final objFuture = _mnSetlistTrack!.toList(qparams);
    final data = await objFuture;
    SetlistTrack? obj;
    if (data.isNotEmpty) {
      obj = SetlistTrack.fromMap(data[0] as Map<String, dynamic>);

      // RELATIONSHIPS PRELOAD
      if (preload || loadParents) {
        loadedFields = loadedFields ?? [];
        if ((preloadFields == null ||
            loadParents ||
            preloadFields.contains('plSetlist'))) {
          obj.plSetlist =
              obj.plSetlist ?? await obj.getSetlist(loadParents: loadParents);
        }
        if ((preloadFields == null ||
            loadParents ||
            preloadFields.contains('plTrack'))) {
          obj.plTrack =
              obj.plTrack ?? await obj.getTrack(loadParents: loadParents);
        }
      } // END RELATIONSHIPS PRELOAD
    } else {
      obj = null;
    }
    return obj;
  }

  /// This method always returns [SetlistTrack]
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  /// ex: toSingle(preload:true) -> Loads all related objects
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  /// ex: toSingle(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  /// <returns> SetlistTrack?
  @override
  Future<SetlistTrack> toSingleOrDefault(
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    return await toSingle(
            preload: preload,
            preloadFields: preloadFields,
            loadParents: loadParents,
            loadedFields: loadedFields) ??
        SetlistTrack();
  }

  /// This method returns int. [SetlistTrack]
  /// <returns>int
  @override
  Future<int> toCount([VoidCallback Function(int c)? setlisttrackCount]) async {
    buildParameters();
    qparams.selectColumns = ['COUNT(1) AS CNT'];
    final setlisttracksFuture = await _mnSetlistTrack!.toList(qparams);
    final int count = setlisttracksFuture[0]['CNT'] as int;
    if (setlisttrackCount != null) {
      setlisttrackCount(count);
    }
    return count;
  }

  /// This method returns List<SetlistTrack> [SetlistTrack]
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  /// ex: toList(preload:true) -> Loads all related objects
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  /// ex: toList(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  /// <returns>List<SetlistTrack>
  @override
  Future<List<SetlistTrack>> toList(
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    final data = await toMapList();
    final List<SetlistTrack> setlisttracksData = await SetlistTrack.fromMapList(
        data,
        preload: preload,
        preloadFields: preloadFields,
        loadParents: loadParents,
        loadedFields: loadedFields,
        setDefaultValues: qparams.selectColumns == null);
    return setlisttracksData;
  }

  /// This method returns Json String [SetlistTrack]
  @override
  Future<String> toJson() async {
    final list = <dynamic>[];
    final data = await toList();
    for (var o in data) {
      list.add(o.toMap(forJson: true));
    }
    return json.encode(list);
  }

  /// This method returns Json String. [SetlistTrack]
  @override
  Future<String> toJsonWithChilds() async {
    final list = <dynamic>[];
    final data = await toList();
    for (var o in data) {
      list.add(await o.toMapWithChildren(false, true));
    }
    return json.encode(list);
  }

  /// This method returns List<dynamic>. [SetlistTrack]
  /// <returns>List<dynamic>
  @override
  Future<List<dynamic>> toMapList() async {
    buildParameters();
    return await _mnSetlistTrack!.toList(qparams);
  }

  /// This method returns Primary Key List SQL and Parameters retVal = Map<String,dynamic>. [SetlistTrack]
  /// retVal['sql'] = SQL statement string, retVal['args'] = whereArguments List<dynamic>;
  /// <returns>List<String>
  @override
  Map<String, dynamic> toListPrimaryKeySQL([bool buildParams = true]) {
    final Map<String, dynamic> _retVal = <String, dynamic>{};
    if (buildParams) {
      buildParameters();
    }
    _retVal['sql'] =
        'SELECT `row__id` FROM SetlistTrack WHERE ${qparams.whereString}';
    _retVal['args'] = qparams.whereArguments;
    return _retVal;
  }

  /// This method returns Primary Key List<String>.
  /// <returns>List<String>
  @override
  Future<List<String>> toListPrimaryKey([bool buildParams = true]) async {
    if (buildParams) {
      buildParameters();
    }
    final List<String> row__idData = <String>[];
    qparams.selectColumns = ['row__id'];
    final row__idFuture = await _mnSetlistTrack!.toList(qparams);

    final int count = row__idFuture.length;
    for (int i = 0; i < count; i++) {
      row__idData.add(row__idFuture[i]['row__id'] as String);
    }
    return row__idData;
  }

  /// Returns List<dynamic> for selected columns. Use this method for 'groupBy' with min,max,avg..  [SetlistTrack]
  /// Sample usage: (see EXAMPLE 4.2 at https://github.com/hhtokpinar/sqfEntity#group-by)
  @override
  Future<List<dynamic>> toListObject() async {
    buildParameters();

    final objectFuture = _mnSetlistTrack!.toList(qparams);

    final List<dynamic> objectsData = <dynamic>[];
    final data = await objectFuture;
    final int count = data.length;
    for (int i = 0; i < count; i++) {
      objectsData.add(data[i]);
    }
    return objectsData;
  }

  /// Returns List<String> for selected first column
  /// Sample usage: await SetlistTrack.select(columnsToSelect: ['columnName']).toListString()
  @override
  Future<List<String>> toListString(
      [VoidCallback Function(List<String> o)? listString]) async {
    buildParameters();

    final objectFuture = _mnSetlistTrack!.toList(qparams);

    final List<String> objectsData = <String>[];
    final data = await objectFuture;
    final int count = data.length;
    for (int i = 0; i < count; i++) {
      objectsData.add(data[i][qparams.selectColumns![0]].toString());
    }
    if (listString != null) {
      listString(objectsData);
    }
    return objectsData;
  }
}
// endregion SetlistTrackFilterBuilder

// region SetlistTrackFields
class SetlistTrackFields {
  static TableField? _fRow__id;
  static TableField get row__id {
    return _fRow__id =
        _fRow__id ?? SqlSyntax.setField(_fRow__id, 'row__id', DbType.integer);
  }

  static TableField? _fRow__sortOrder;
  static TableField get row__sortOrder {
    return _fRow__sortOrder = _fRow__sortOrder ??
        SqlSyntax.setField(_fRow__sortOrder, 'row__sortOrder', DbType.integer);
  }

  static TableField? _fNotes;
  static TableField get notes {
    return _fNotes =
        _fNotes ?? SqlSyntax.setField(_fNotes, 'notes', DbType.text);
  }

  static TableField? _fSetlistId;
  static TableField get setlistId {
    return _fSetlistId = _fSetlistId ??
        SqlSyntax.setField(_fSetlistId, 'setlistId', DbType.text);
  }

  static TableField? _fSetlistType;
  static TableField get setlistType {
    return _fSetlistType = _fSetlistType ??
        SqlSyntax.setField(_fSetlistType, 'setlistType', DbType.integer);
  }

  static TableField? _fTrackId;
  static TableField get trackId {
    return _fTrackId =
        _fTrackId ?? SqlSyntax.setField(_fTrackId, 'trackId', DbType.text);
  }
}
// endregion SetlistTrackFields

//region SetlistTrackManager
class SetlistTrackManager extends SqfEntityProvider {
  SetlistTrackManager()
      : super(Setlistdb(),
            tableName: _tableName,
            primaryKeyList: _primaryKeyList,
            whereStr: _whereStr);
  static const String _tableName = 'SetlistTrack';
  static const List<String> _primaryKeyList = ['row__id'];
  static const String _whereStr = 'row__id=?';
}

//endregion SetlistTrackManager
// region Track
class Track extends TableBase {
  Track(
      {this.row__id,
      this.title,
      this.notes,
      this.row__sortOrder,
      this.spotifyId,
      this.spotifyAudioFeatures,
      this.countOutBars}) {
    _setDefaultValues();
    softDeleteActivated = false;
  }
  Track.withFields(this.row__id, this.title, this.notes, this.row__sortOrder,
      this.spotifyId, this.spotifyAudioFeatures, this.countOutBars) {
    _setDefaultValues();
  }
  Track.withId(this.row__id, this.title, this.notes, this.row__sortOrder,
      this.spotifyId, this.spotifyAudioFeatures, this.countOutBars) {
    _setDefaultValues();
  }
  // fromMap v2.0
  Track.fromMap(Map<String, dynamic> o, {bool setDefaultValues = true}) {
    if (setDefaultValues) {
      _setDefaultValues();
    }
    row__id = o['row__id'].toString();
    if (o['title'] != null) {
      title = o['title'].toString();
    }
    if (o['notes'] != null) {
      notes = o['notes'].toString();
    }
    if (o['row__sortOrder'] != null) {
      row__sortOrder = int.tryParse(o['row__sortOrder'].toString());
    }
    if (o['spotifyId'] != null) {
      spotifyId = o['spotifyId'].toString();
    }
    if (o['spotifyAudioFeatures'] != null) {
      spotifyAudioFeatures = o['spotifyAudioFeatures'].toString();
    }
    if (o['countOutBars'] != null) {
      countOutBars = o['countOutBars'].toString();
    }

    isSaved = true;
  }
  // FIELDS (Track)
  String? row__id;
  String? title;
  String? notes;
  int? row__sortOrder;
  String? spotifyId;
  String? spotifyAudioFeatures;
  String? countOutBars;
  bool? isSaved;
  // end FIELDS (Track)

// COLLECTIONS & VIRTUALS (Track)
  /// to load children of items to this field, use preload parameter. Ex: toList(preload:true) or toSingle(preload:true) or getById(preload:true)
  /// You can also specify this object into certain preload fields!. Ex: toList(preload:true, preloadFields:['plSetlistTracks', 'plField2'..]) or so on..
  List<SetlistTrack>? plSetlistTracks;

  /// get SetlistTrack(s) filtered by row__id=trackId
  SetlistTrackFilterBuilder? getSetlistTracks(
      {List<String>? columnsToSelect, bool? getIsDeleted}) {
    if (row__id == null) {
      return null;
    }
    return SetlistTrack()
        .select(columnsToSelect: columnsToSelect, getIsDeleted: getIsDeleted)
        .trackId
        .equals(row__id)
        .and;
  }

  /// to load children of items to this field, use preload parameter. Ex: toList(preload:true) or toSingle(preload:true) or getById(preload:true)
  /// You can also specify this object into certain preload fields!. Ex: toList(preload:true, preloadFields:['plTempos', 'plField2'..]) or so on..
  List<Tempo>? plTempos;

  /// get Tempo(s) filtered by row__id=trackId
  TempoFilterBuilder? getTempos(
      {List<String>? columnsToSelect, bool? getIsDeleted}) {
    if (row__id == null) {
      return null;
    }
    return Tempo()
        .select(columnsToSelect: columnsToSelect, getIsDeleted: getIsDeleted)
        .trackId
        .equals(row__id)
        .and;
  }

// END COLLECTIONS & VIRTUALS (Track)

  static const bool _softDeleteActivated = false;
  TrackManager? __mnTrack;

  TrackManager get _mnTrack {
    return __mnTrack = __mnTrack ?? TrackManager();
  }

  // METHODS
  @override
  Map<String, dynamic> toMap(
      {bool forQuery = false, bool forJson = false, bool forView = false}) {
    final map = <String, dynamic>{};
    map['row__id'] = row__id;
    if (title != null || !forView) {
      map['title'] = title;
    }
    if (notes != null || !forView) {
      map['notes'] = notes;
    }
    if (row__sortOrder != null || !forView) {
      map['row__sortOrder'] = row__sortOrder;
    }
    if (spotifyId != null || !forView) {
      map['spotifyId'] = spotifyId;
    }
    if (spotifyAudioFeatures != null || !forView) {
      map['spotifyAudioFeatures'] = spotifyAudioFeatures;
    }
    if (countOutBars != null || !forView) {
      map['countOutBars'] = countOutBars;
    }

    return map;
  }

  @override
  Future<Map<String, dynamic>> toMapWithChildren(
      [bool forQuery = false,
      bool forJson = false,
      bool forView = false]) async {
    final map = <String, dynamic>{};
    map['row__id'] = row__id;
    if (title != null || !forView) {
      map['title'] = title;
    }
    if (notes != null || !forView) {
      map['notes'] = notes;
    }
    if (row__sortOrder != null || !forView) {
      map['row__sortOrder'] = row__sortOrder;
    }
    if (spotifyId != null || !forView) {
      map['spotifyId'] = spotifyId;
    }
    if (spotifyAudioFeatures != null || !forView) {
      map['spotifyAudioFeatures'] = spotifyAudioFeatures;
    }
    if (countOutBars != null || !forView) {
      map['countOutBars'] = countOutBars;
    }

// COLLECTIONS (Track)
    if (!forQuery) {
      map['SetlistTracks'] = await getSetlistTracks()!.toMapList();
    }
    if (!forQuery) {
      map['Tempos'] = await getTempos()!.toMapList();
    }
// END COLLECTIONS (Track)

    return map;
  }

  /// This method returns Json String [Track]
  @override
  String toJson() {
    return json.encode(toMap(forJson: true));
  }

  /// This method returns Json String [Track]
  @override
  Future<String> toJsonWithChilds() async {
    return json.encode(await toMapWithChildren(false, true));
  }

  @override
  List<dynamic> toArgs() {
    return [
      row__id,
      title,
      notes,
      row__sortOrder,
      spotifyId,
      spotifyAudioFeatures,
      countOutBars
    ];
  }

  @override
  List<dynamic> toArgsWithIds() {
    return [
      row__id,
      title,
      notes,
      row__sortOrder,
      spotifyId,
      spotifyAudioFeatures,
      countOutBars
    ];
  }

  static Future<List<Track>?> fromWebUrl(Uri uri,
      {Map<String, String>? headers}) async {
    try {
      final response = await http.get(uri, headers: headers);
      return await fromJson(response.body);
    } catch (e) {
      debugPrint(
          'SQFENTITY ERROR Track.fromWebUrl: ErrorMessage: ${e.toString()}');
      return null;
    }
  }

  Future<http.Response> postUrl(Uri uri, {Map<String, String>? headers}) {
    return http.post(uri, headers: headers, body: toJson());
  }

  static Future<List<Track>> fromJson(String jsonBody) async {
    final Iterable list = await json.decode(jsonBody) as Iterable;
    var objList = <Track>[];
    try {
      objList = list
          .map((track) => Track.fromMap(track as Map<String, dynamic>))
          .toList();
    } catch (e) {
      debugPrint(
          'SQFENTITY ERROR Track.fromJson: ErrorMessage: ${e.toString()}');
    }
    return objList;
  }

  static Future<List<Track>> fromMapList(List<dynamic> data,
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields,
      bool setDefaultValues = true}) async {
    final List<Track> objList = <Track>[];
    loadedFields = loadedFields ?? [];
    for (final map in data) {
      final obj = Track.fromMap(map as Map<String, dynamic>,
          setDefaultValues: setDefaultValues);
      // final List<String> _loadedFields = List<String>.from(loadedFields);

      // RELATIONSHIPS PRELOAD CHILD
      if (preload) {
        loadedFields = loadedFields ?? [];
        if (/*!_loadedfields!.contains('Track.plSetlistTracks') && */ (preloadFields ==
                null ||
            preloadFields.contains('plSetlistTracks'))) {
          /*_loadedfields!.add('Track.plSetlistTracks'); */ obj
                  .plSetlistTracks =
              obj.plSetlistTracks ??
                  await obj.getSetlistTracks()!.toList(
                      preload: preload,
                      preloadFields: preloadFields,
                      loadParents: false /*, loadedFields:_loadedFields*/);
        }
        if (/*!_loadedfields!.contains('Track.plTempos') && */ (preloadFields ==
                null ||
            preloadFields.contains('plTempos'))) {
          /*_loadedfields!.add('Track.plTempos'); */ obj.plTempos =
              obj.plTempos ??
                  await obj.getTempos()!.toList(
                      preload: preload,
                      preloadFields: preloadFields,
                      loadParents: false /*, loadedFields:_loadedFields*/);
        }
      } // END RELATIONSHIPS PRELOAD CHILD

      objList.add(obj);
    }
    return objList;
  }

  /// returns Track by ID if exist, otherwise returns null
  /// Primary Keys: String? row__id
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  /// ex: getById(preload:true) -> Loads all related objects
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  /// ex: getById(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  /// <returns>returns [Track] if exist, otherwise returns null
  Future<Track?> getById(String? row__id,
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    if (row__id == null) {
      return null;
    }
    Track? obj;
    final data = await _mnTrack.getById([row__id]);
    if (data.length != 0) {
      obj = Track.fromMap(data[0] as Map<String, dynamic>);

      // RELATIONSHIPS PRELOAD CHILD
      if (preload) {
        loadedFields = loadedFields ?? [];
        if (/*!_loadedfields!.contains('Track.plSetlistTracks') && */ (preloadFields ==
                null ||
            preloadFields.contains('plSetlistTracks'))) {
          /*_loadedfields!.add('Track.plSetlistTracks'); */ obj
                  .plSetlistTracks =
              obj.plSetlistTracks ??
                  await obj.getSetlistTracks()!.toList(
                      preload: preload,
                      preloadFields: preloadFields,
                      loadParents: false /*, loadedFields:_loadedFields*/);
        }
        if (/*!_loadedfields!.contains('Track.plTempos') && */ (preloadFields ==
                null ||
            preloadFields.contains('plTempos'))) {
          /*_loadedfields!.add('Track.plTempos'); */ obj.plTempos =
              obj.plTempos ??
                  await obj.getTempos()!.toList(
                      preload: preload,
                      preloadFields: preloadFields,
                      loadParents: false /*, loadedFields:_loadedFields*/);
        }
      } // END RELATIONSHIPS PRELOAD CHILD
    } else {
      obj = null;
    }
    return obj;
  }

  /// Saves the (Track) object. If the Primary Key (row__id) field is null, returns Error.
  /// INSERTS (If not exist) OR REPLACES (If exist) data while Primary Key is not null.
  /// Call the saveAs() method if you do not want to save it when there is another row with the same row__id
  /// <returns>Returns BoolResult
  @override
  Future<BoolResult> save({bool ignoreBatch = true}) async {
    final result = BoolResult(success: false);
    try {
      await _mnTrack.rawInsert(
          'INSERT ${isSaved! ? 'OR REPLACE' : ''} INTO Track (row__id, title, notes, row__sortOrder, spotifyId, spotifyAudioFeatures, countOutBars)  VALUES (?,?,?,?,?,?,?)',
          toArgsWithIds(),
          ignoreBatch);
      result.success = true;
      isSaved = true;
    } catch (e) {
      result.errorMessage = e.toString();
    }

    saveResult = result;
    return result;
  }

  /// saveAll method saves the sent List<Track> as a bulk in one transaction
  /// Returns a <List<BoolResult>>
  static Future<List<dynamic>> saveAll(List<Track> tracks,
      {bool? exclusive, bool? noResult, bool? continueOnError}) async {
    List<dynamic>? result = [];
    // If there is no open transaction, start one
    final isStartedBatch = await Setlistdb().batchStart();
    for (final obj in tracks) {
      await obj.save();
    }
    if (!isStartedBatch) {
      result = await Setlistdb().batchCommit(
          exclusive: exclusive,
          noResult: noResult,
          continueOnError: continueOnError);
    }
    return result!;
  }

  /// Updates if the record exists, otherwise adds a new row
  /// <returns>Returns 1
  @override
  Future<int?> upsert({bool ignoreBatch = true}) async {
    try {
      final result = await _mnTrack.rawInsert(
          'INSERT OR REPLACE INTO Track (row__id, title, notes, row__sortOrder, spotifyId, spotifyAudioFeatures, countOutBars)  VALUES (?,?,?,?,?,?,?)',
          [
            row__id,
            title,
            notes,
            row__sortOrder,
            spotifyId,
            spotifyAudioFeatures,
            countOutBars
          ],
          ignoreBatch);
      if (result! > 0) {
        saveResult = BoolResult(
            success: true,
            successMessage: 'Track row__id=$row__id updated successfully');
      } else {
        saveResult = BoolResult(
            success: false,
            errorMessage: 'Track row__id=$row__id did not update');
      }
      return 1;
    } catch (e) {
      saveResult = BoolResult(
          success: false,
          errorMessage: 'Track Save failed. Error: ${e.toString()}');
      return null;
    }
  }

  /// Deletes Track

  /// <returns>BoolResult res.success= true (Deleted), false (Could not be deleted)
  @override
  Future<BoolResult> delete([bool hardDelete = false]) async {
    debugPrint('SQFENTITIY: delete Track invoked (row__id=$row__id)');
    if (await SetlistTrack().select().trackId.equals(row__id).and.toCount() >
        0) {
      return BoolResult(
          success: false,
          errorMessage:
              'SQFENTITY ERROR: The DELETE statement conflicted with the REFERENCE RELATIONSHIP (SetlistTrack.trackId)');
    }
    if (await Tempo().select().trackId.equals(row__id).and.toCount() > 0) {
      return BoolResult(
          success: false,
          errorMessage:
              'SQFENTITY ERROR: The DELETE statement conflicted with the REFERENCE RELATIONSHIP (Tempo.trackId)');
    }
    if (!_softDeleteActivated || hardDelete) {
      return _mnTrack.delete(
          QueryParams(whereString: 'row__id=?', whereArguments: [row__id]));
    } else {
      return _mnTrack.updateBatch(
          QueryParams(whereString: 'row__id=?', whereArguments: [row__id]),
          {'isDeleted': 1});
    }
  }

  @override
  Future<BoolResult> recover([bool recoverChilds = true]) {
    // not implemented because:
    final msg =
        'set useSoftDeleting:true in the table definition of [Track] to use this feature';
    throw UnimplementedError(msg);
  }

  @override
  TrackFilterBuilder select(
      {List<String>? columnsToSelect, bool? getIsDeleted}) {
    return TrackFilterBuilder(this, getIsDeleted)
      ..qparams.selectColumns = columnsToSelect;
  }

  @override
  TrackFilterBuilder distinct(
      {List<String>? columnsToSelect, bool? getIsDeleted}) {
    return TrackFilterBuilder(this, getIsDeleted)
      ..qparams.selectColumns = columnsToSelect
      ..qparams.distinct = true;
  }

  void _setDefaultValues() {
    isSaved = false;
    row__sortOrder = row__sortOrder ?? 1;
  }

  @override
  void rollbackPk() {
    if (isInsert == true) {
      row__id = null;
    }
  }

  // END METHODS
  // BEGIN CUSTOM CODE
  /*
      you can define customCode property of your SqfEntityTable constant. For example:
      const tablePerson = SqfEntityTable(
      tableName: 'person',
      primaryKeyName: 'id',
      primaryKeyType: PrimaryKeyType.integer_auto_incremental,
      fields: [
        SqfEntityField('firstName', DbType.text),
        SqfEntityField('lastName', DbType.text),
      ],
      customCode: '''
       String fullName()
       { 
         return '$firstName $lastName';
       }
      ''');
     */
  // END CUSTOM CODE
}
// endregion track

// region TrackField
class TrackField extends FilterBase {
  TrackField(TrackFilterBuilder trackFB) : super(trackFB);

  @override
  TrackFilterBuilder equals(dynamic pValue) {
    return super.equals(pValue) as TrackFilterBuilder;
  }

  @override
  TrackFilterBuilder equalsOrNull(dynamic pValue) {
    return super.equalsOrNull(pValue) as TrackFilterBuilder;
  }

  @override
  TrackFilterBuilder isNull() {
    return super.isNull() as TrackFilterBuilder;
  }

  @override
  TrackFilterBuilder contains(dynamic pValue) {
    return super.contains(pValue) as TrackFilterBuilder;
  }

  @override
  TrackFilterBuilder startsWith(dynamic pValue) {
    return super.startsWith(pValue) as TrackFilterBuilder;
  }

  @override
  TrackFilterBuilder endsWith(dynamic pValue) {
    return super.endsWith(pValue) as TrackFilterBuilder;
  }

  @override
  TrackFilterBuilder between(dynamic pFirst, dynamic pLast) {
    return super.between(pFirst, pLast) as TrackFilterBuilder;
  }

  @override
  TrackFilterBuilder greaterThan(dynamic pValue) {
    return super.greaterThan(pValue) as TrackFilterBuilder;
  }

  @override
  TrackFilterBuilder lessThan(dynamic pValue) {
    return super.lessThan(pValue) as TrackFilterBuilder;
  }

  @override
  TrackFilterBuilder greaterThanOrEquals(dynamic pValue) {
    return super.greaterThanOrEquals(pValue) as TrackFilterBuilder;
  }

  @override
  TrackFilterBuilder lessThanOrEquals(dynamic pValue) {
    return super.lessThanOrEquals(pValue) as TrackFilterBuilder;
  }

  @override
  TrackFilterBuilder inValues(dynamic pValue) {
    return super.inValues(pValue) as TrackFilterBuilder;
  }

  @override
  TrackField get not {
    return super.not as TrackField;
  }
}
// endregion TrackField

// region TrackFilterBuilder
class TrackFilterBuilder extends ConjunctionBase {
  TrackFilterBuilder(Track obj, bool? getIsDeleted) : super(obj, getIsDeleted) {
    _mnTrack = obj._mnTrack;
    _softDeleteActivated = obj.softDeleteActivated;
  }

  bool _softDeleteActivated = false;
  TrackManager? _mnTrack;

  /// put the sql keyword 'AND'
  @override
  TrackFilterBuilder get and {
    super.and;
    return this;
  }

  /// put the sql keyword 'OR'
  @override
  TrackFilterBuilder get or {
    super.or;
    return this;
  }

  /// open parentheses
  @override
  TrackFilterBuilder get startBlock {
    super.startBlock;
    return this;
  }

  /// String whereCriteria, write raw query without 'where' keyword. Like this: 'field1 like 'test%' and field2 = 3'
  @override
  TrackFilterBuilder where(String? whereCriteria, {dynamic parameterValue}) {
    super.where(whereCriteria, parameterValue: parameterValue);
    return this;
  }

  /// page = page number,
  /// pagesize = row(s) per page
  @override
  TrackFilterBuilder page(int page, int pagesize) {
    super.page(page, pagesize);
    return this;
  }

  /// int count = LIMIT
  @override
  TrackFilterBuilder top(int count) {
    super.top(count);
    return this;
  }

  /// close parentheses
  @override
  TrackFilterBuilder get endBlock {
    super.endBlock;
    return this;
  }

  /// argFields might be String or List<String>.
  /// Example 1: argFields='name, date'
  /// Example 2: argFields = ['name', 'date']
  @override
  TrackFilterBuilder orderBy(dynamic argFields) {
    super.orderBy(argFields);
    return this;
  }

  /// argFields might be String or List<String>.
  /// Example 1: argFields='field1, field2'
  /// Example 2: argFields = ['field1', 'field2']
  @override
  TrackFilterBuilder orderByDesc(dynamic argFields) {
    super.orderByDesc(argFields);
    return this;
  }

  /// argFields might be String or List<String>.
  /// Example 1: argFields='field1, field2'
  /// Example 2: argFields = ['field1', 'field2']
  @override
  TrackFilterBuilder groupBy(dynamic argFields) {
    super.groupBy(argFields);
    return this;
  }

  /// argFields might be String or List<String>.
  /// Example 1: argFields='name, date'
  /// Example 2: argFields = ['name', 'date']
  @override
  TrackFilterBuilder having(dynamic argFields) {
    super.having(argFields);
    return this;
  }

  TrackField _setField(TrackField? field, String colName, DbType dbtype) {
    return TrackField(this)
      ..param = DbParameter(
          dbType: dbtype, columnName: colName, wStartBlock: openedBlock);
  }

  TrackField? _row__id;
  TrackField get row__id {
    return _row__id = _setField(_row__id, 'row__id', DbType.integer);
  }

  TrackField? _title;
  TrackField get title {
    return _title = _setField(_title, 'title', DbType.text);
  }

  TrackField? _notes;
  TrackField get notes {
    return _notes = _setField(_notes, 'notes', DbType.text);
  }

  TrackField? _row__sortOrder;
  TrackField get row__sortOrder {
    return _row__sortOrder =
        _setField(_row__sortOrder, 'row__sortOrder', DbType.integer);
  }

  TrackField? _spotifyId;
  TrackField get spotifyId {
    return _spotifyId = _setField(_spotifyId, 'spotifyId', DbType.text);
  }

  TrackField? _spotifyAudioFeatures;
  TrackField get spotifyAudioFeatures {
    return _spotifyAudioFeatures =
        _setField(_spotifyAudioFeatures, 'spotifyAudioFeatures', DbType.text);
  }

  TrackField? _countOutBars;
  TrackField get countOutBars {
    return _countOutBars =
        _setField(_countOutBars, 'countOutBars', DbType.text);
  }

  /// Deletes List<Track> bulk by query
  ///
  /// <returns>BoolResult res.success= true (Deleted), false (Could not be deleted)
  @override
  Future<BoolResult> delete([bool hardDelete = false]) async {
    buildParameters();
    var r = BoolResult(success: false);
    // Check sub records where in (SetlistTrack) according to DeleteRule.NO_ACTION

    final idListSetlistTrackBYtrackId = toListPrimaryKeySQL(false);
    final resSetlistTrackBYtrackId = await SetlistTrack()
        .select()
        .where('trackId IN (${idListSetlistTrackBYtrackId['sql']})',
            parameterValue: idListSetlistTrackBYtrackId['args'])
        .toCount();
    if (resSetlistTrackBYtrackId > 0) {
      return BoolResult(
          success: false,
          errorMessage:
              'SQFENTITY ERROR: The DELETE statement conflicted with the REFERENCE RELATIONSHIP (SetlistTrack.trackId)');
    }
// Check sub records where in (Tempo) according to DeleteRule.NO_ACTION

    final idListTempoBYtrackId = toListPrimaryKeySQL(false);
    final resTempoBYtrackId = await Tempo()
        .select()
        .where('trackId IN (${idListTempoBYtrackId['sql']})',
            parameterValue: idListTempoBYtrackId['args'])
        .toCount();
    if (resTempoBYtrackId > 0) {
      return BoolResult(
          success: false,
          errorMessage:
              'SQFENTITY ERROR: The DELETE statement conflicted with the REFERENCE RELATIONSHIP (Tempo.trackId)');
    }

    if (_softDeleteActivated && !hardDelete) {
      r = await _mnTrack!.updateBatch(qparams, {'isDeleted': 1});
    } else {
      r = await _mnTrack!.delete(qparams);
    }
    return r;
  }

  /// using:
  /// update({'fieldName': Value})
  /// fieldName must be String. Value is dynamic, it can be any of the (int, bool, String.. )
  @override
  Future<BoolResult> update(Map<String, dynamic> values) {
    buildParameters();
    if (qparams.limit! > 0 || qparams.offset! > 0) {
      qparams.whereString =
          'row__id IN (SELECT row__id from Track ${qparams.whereString!.isNotEmpty ? 'WHERE ${qparams.whereString}' : ''}${qparams.limit! > 0 ? ' LIMIT ${qparams.limit}' : ''}${qparams.offset! > 0 ? ' OFFSET ${qparams.offset}' : ''})';
    }
    return _mnTrack!.updateBatch(qparams, values);
  }

  /// This method always returns [Track] Obj if exist, otherwise returns null
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  /// ex: toSingle(preload:true) -> Loads all related objects
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  /// ex: toSingle(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  /// <returns> Track?
  @override
  Future<Track?> toSingle(
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    buildParameters(pSize: 1);
    final objFuture = _mnTrack!.toList(qparams);
    final data = await objFuture;
    Track? obj;
    if (data.isNotEmpty) {
      obj = Track.fromMap(data[0] as Map<String, dynamic>);

      // RELATIONSHIPS PRELOAD CHILD
      if (preload) {
        loadedFields = loadedFields ?? [];
        if (/*!_loadedfields!.contains('Track.plSetlistTracks') && */ (preloadFields ==
                null ||
            preloadFields.contains('plSetlistTracks'))) {
          /*_loadedfields!.add('Track.plSetlistTracks'); */ obj
                  .plSetlistTracks =
              obj.plSetlistTracks ??
                  await obj.getSetlistTracks()!.toList(
                      preload: preload,
                      preloadFields: preloadFields,
                      loadParents: false /*, loadedFields:_loadedFields*/);
        }
        if (/*!_loadedfields!.contains('Track.plTempos') && */ (preloadFields ==
                null ||
            preloadFields.contains('plTempos'))) {
          /*_loadedfields!.add('Track.plTempos'); */ obj.plTempos =
              obj.plTempos ??
                  await obj.getTempos()!.toList(
                      preload: preload,
                      preloadFields: preloadFields,
                      loadParents: false /*, loadedFields:_loadedFields*/);
        }
      } // END RELATIONSHIPS PRELOAD CHILD
    } else {
      obj = null;
    }
    return obj;
  }

  /// This method always returns [Track]
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  /// ex: toSingle(preload:true) -> Loads all related objects
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  /// ex: toSingle(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  /// <returns> Track?
  @override
  Future<Track> toSingleOrDefault(
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    return await toSingle(
            preload: preload,
            preloadFields: preloadFields,
            loadParents: loadParents,
            loadedFields: loadedFields) ??
        Track();
  }

  /// This method returns int. [Track]
  /// <returns>int
  @override
  Future<int> toCount([VoidCallback Function(int c)? trackCount]) async {
    buildParameters();
    qparams.selectColumns = ['COUNT(1) AS CNT'];
    final tracksFuture = await _mnTrack!.toList(qparams);
    final int count = tracksFuture[0]['CNT'] as int;
    if (trackCount != null) {
      trackCount(count);
    }
    return count;
  }

  /// This method returns List<Track> [Track]
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  /// ex: toList(preload:true) -> Loads all related objects
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  /// ex: toList(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  /// <returns>List<Track>
  @override
  Future<List<Track>> toList(
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    final data = await toMapList();
    final List<Track> tracksData = await Track.fromMapList(data,
        preload: preload,
        preloadFields: preloadFields,
        loadParents: loadParents,
        loadedFields: loadedFields,
        setDefaultValues: qparams.selectColumns == null);
    return tracksData;
  }

  /// This method returns Json String [Track]
  @override
  Future<String> toJson() async {
    final list = <dynamic>[];
    final data = await toList();
    for (var o in data) {
      list.add(o.toMap(forJson: true));
    }
    return json.encode(list);
  }

  /// This method returns Json String. [Track]
  @override
  Future<String> toJsonWithChilds() async {
    final list = <dynamic>[];
    final data = await toList();
    for (var o in data) {
      list.add(await o.toMapWithChildren(false, true));
    }
    return json.encode(list);
  }

  /// This method returns List<dynamic>. [Track]
  /// <returns>List<dynamic>
  @override
  Future<List<dynamic>> toMapList() async {
    buildParameters();
    return await _mnTrack!.toList(qparams);
  }

  /// This method returns Primary Key List SQL and Parameters retVal = Map<String,dynamic>. [Track]
  /// retVal['sql'] = SQL statement string, retVal['args'] = whereArguments List<dynamic>;
  /// <returns>List<String>
  @override
  Map<String, dynamic> toListPrimaryKeySQL([bool buildParams = true]) {
    final Map<String, dynamic> _retVal = <String, dynamic>{};
    if (buildParams) {
      buildParameters();
    }
    _retVal['sql'] = 'SELECT `row__id` FROM Track WHERE ${qparams.whereString}';
    _retVal['args'] = qparams.whereArguments;
    return _retVal;
  }

  /// This method returns Primary Key List<String>.
  /// <returns>List<String>
  @override
  Future<List<String>> toListPrimaryKey([bool buildParams = true]) async {
    if (buildParams) {
      buildParameters();
    }
    final List<String> row__idData = <String>[];
    qparams.selectColumns = ['row__id'];
    final row__idFuture = await _mnTrack!.toList(qparams);

    final int count = row__idFuture.length;
    for (int i = 0; i < count; i++) {
      row__idData.add(row__idFuture[i]['row__id'] as String);
    }
    return row__idData;
  }

  /// Returns List<dynamic> for selected columns. Use this method for 'groupBy' with min,max,avg..  [Track]
  /// Sample usage: (see EXAMPLE 4.2 at https://github.com/hhtokpinar/sqfEntity#group-by)
  @override
  Future<List<dynamic>> toListObject() async {
    buildParameters();

    final objectFuture = _mnTrack!.toList(qparams);

    final List<dynamic> objectsData = <dynamic>[];
    final data = await objectFuture;
    final int count = data.length;
    for (int i = 0; i < count; i++) {
      objectsData.add(data[i]);
    }
    return objectsData;
  }

  /// Returns List<String> for selected first column
  /// Sample usage: await Track.select(columnsToSelect: ['columnName']).toListString()
  @override
  Future<List<String>> toListString(
      [VoidCallback Function(List<String> o)? listString]) async {
    buildParameters();

    final objectFuture = _mnTrack!.toList(qparams);

    final List<String> objectsData = <String>[];
    final data = await objectFuture;
    final int count = data.length;
    for (int i = 0; i < count; i++) {
      objectsData.add(data[i][qparams.selectColumns![0]].toString());
    }
    if (listString != null) {
      listString(objectsData);
    }
    return objectsData;
  }
}
// endregion TrackFilterBuilder

// region TrackFields
class TrackFields {
  static TableField? _fRow__id;
  static TableField get row__id {
    return _fRow__id =
        _fRow__id ?? SqlSyntax.setField(_fRow__id, 'row__id', DbType.integer);
  }

  static TableField? _fTitle;
  static TableField get title {
    return _fTitle =
        _fTitle ?? SqlSyntax.setField(_fTitle, 'title', DbType.text);
  }

  static TableField? _fNotes;
  static TableField get notes {
    return _fNotes =
        _fNotes ?? SqlSyntax.setField(_fNotes, 'notes', DbType.text);
  }

  static TableField? _fRow__sortOrder;
  static TableField get row__sortOrder {
    return _fRow__sortOrder = _fRow__sortOrder ??
        SqlSyntax.setField(_fRow__sortOrder, 'row__sortOrder', DbType.integer);
  }

  static TableField? _fSpotifyId;
  static TableField get spotifyId {
    return _fSpotifyId = _fSpotifyId ??
        SqlSyntax.setField(_fSpotifyId, 'spotifyId', DbType.text);
  }

  static TableField? _fSpotifyAudioFeatures;
  static TableField get spotifyAudioFeatures {
    return _fSpotifyAudioFeatures = _fSpotifyAudioFeatures ??
        SqlSyntax.setField(
            _fSpotifyAudioFeatures, 'spotifyAudioFeatures', DbType.text);
  }

  static TableField? _fCountOutBars;
  static TableField get countOutBars {
    return _fCountOutBars = _fCountOutBars ??
        SqlSyntax.setField(_fCountOutBars, 'countOutBars', DbType.text);
  }
}
// endregion TrackFields

//region TrackManager
class TrackManager extends SqfEntityProvider {
  TrackManager()
      : super(Setlistdb(),
            tableName: _tableName,
            primaryKeyList: _primaryKeyList,
            whereStr: _whereStr);
  static const String _tableName = 'Track';
  static const List<String> _primaryKeyList = ['row__id'];
  static const String _whereStr = 'row__id=?';
}

//endregion TrackManager
// region Tempo
class Tempo extends TableBase {
  Tempo(
      {this.row__id,
      this.row__sortOrder,
      this.bpm,
      this.beatsPerBar,
      this.beatUnit,
      this.dottedQuarterAccent,
      this.accentBeatsPerBar,
      this.numberOfBars,
      this.trackId}) {
    _setDefaultValues();
    softDeleteActivated = false;
  }
  Tempo.withFields(
      this.row__id,
      this.row__sortOrder,
      this.bpm,
      this.beatsPerBar,
      this.beatUnit,
      this.dottedQuarterAccent,
      this.accentBeatsPerBar,
      this.numberOfBars,
      this.trackId) {
    _setDefaultValues();
  }
  Tempo.withId(
      this.row__id,
      this.row__sortOrder,
      this.bpm,
      this.beatsPerBar,
      this.beatUnit,
      this.dottedQuarterAccent,
      this.accentBeatsPerBar,
      this.numberOfBars,
      this.trackId) {
    _setDefaultValues();
  }
  // fromMap v2.0
  Tempo.fromMap(Map<String, dynamic> o, {bool setDefaultValues = true}) {
    if (setDefaultValues) {
      _setDefaultValues();
    }
    row__id = o['row__id'].toString();
    if (o['row__sortOrder'] != null) {
      row__sortOrder = int.tryParse(o['row__sortOrder'].toString());
    }
    if (o['bpm'] != null) {
      bpm = double.tryParse(o['bpm'].toString());
    }
    if (o['beatsPerBar'] != null) {
      beatsPerBar = int.tryParse(o['beatsPerBar'].toString());
    }
    if (o['beatUnit'] != null) {
      beatUnit = int.tryParse(o['beatUnit'].toString());
    }
    if (o['dottedQuarterAccent'] != null) {
      dottedQuarterAccent = o['dottedQuarterAccent'].toString() == '1' ||
          o['dottedQuarterAccent'].toString() == 'true';
    }
    if (o['accentBeatsPerBar'] != null) {
      accentBeatsPerBar = int.tryParse(o['accentBeatsPerBar'].toString());
    }
    if (o['numberOfBars'] != null) {
      numberOfBars = double.tryParse(o['numberOfBars'].toString());
    }
    trackId = o['trackId'].toString();

    // RELATIONSHIPS FromMAP
    plTrack = o['track'] != null
        ? Track.fromMap(o['track'] as Map<String, dynamic>)
        : null;
    // END RELATIONSHIPS FromMAP

    isSaved = true;
  }
  // FIELDS (Tempo)
  String? row__id;
  int? row__sortOrder;
  double? bpm;
  int? beatsPerBar;
  int? beatUnit;
  bool? dottedQuarterAccent;
  int? accentBeatsPerBar;
  double? numberOfBars;
  String? trackId;
  bool? isSaved;
  // end FIELDS (Tempo)

// RELATIONSHIPS (Tempo)
  /// to load parent of items to this field, use preload parameter ex: toList(preload:true) or toSingle(preload:true) or getById(preload:true)
  /// You can also specify this object into certain preload fields!. Ex: toList(preload:true, preloadFields:['plTrack', 'plField2'..]) or so on..
  Track? plTrack;

  /// get Track By TrackId
  Future<Track?> getTrack(
      {bool loadParents = false, List<String>? loadedFields}) async {
    final _obj = await Track()
        .getById(trackId, loadParents: loadParents, loadedFields: loadedFields);
    return _obj;
  }
  // END RELATIONSHIPS (Tempo)

  static const bool _softDeleteActivated = false;
  TempoManager? __mnTempo;

  TempoManager get _mnTempo {
    return __mnTempo = __mnTempo ?? TempoManager();
  }

  // METHODS
  @override
  Map<String, dynamic> toMap(
      {bool forQuery = false, bool forJson = false, bool forView = false}) {
    final map = <String, dynamic>{};
    map['row__id'] = row__id;
    if (row__sortOrder != null || !forView) {
      map['row__sortOrder'] = row__sortOrder;
    }
    if (bpm != null || !forView) {
      map['bpm'] = bpm;
    }
    if (beatsPerBar != null || !forView) {
      map['beatsPerBar'] = beatsPerBar;
    }
    if (beatUnit != null || !forView) {
      map['beatUnit'] = beatUnit;
    }
    if (dottedQuarterAccent != null) {
      map['dottedQuarterAccent'] =
          forQuery ? (dottedQuarterAccent! ? 1 : 0) : dottedQuarterAccent;
    } else if (dottedQuarterAccent != null || !forView) {
      map['dottedQuarterAccent'] = null;
    }
    if (accentBeatsPerBar != null || !forView) {
      map['accentBeatsPerBar'] = accentBeatsPerBar;
    }
    if (numberOfBars != null || !forView) {
      map['numberOfBars'] = numberOfBars;
    }
    if (trackId != null) {
      map['trackId'] = forView
          ? plTrack == null
              ? trackId
              : plTrack!.title
          : trackId;
    } else if (trackId != null || !forView) {
      map['trackId'] = null;
    }

    return map;
  }

  @override
  Future<Map<String, dynamic>> toMapWithChildren(
      [bool forQuery = false,
      bool forJson = false,
      bool forView = false]) async {
    final map = <String, dynamic>{};
    map['row__id'] = row__id;
    if (row__sortOrder != null || !forView) {
      map['row__sortOrder'] = row__sortOrder;
    }
    if (bpm != null || !forView) {
      map['bpm'] = bpm;
    }
    if (beatsPerBar != null || !forView) {
      map['beatsPerBar'] = beatsPerBar;
    }
    if (beatUnit != null || !forView) {
      map['beatUnit'] = beatUnit;
    }
    if (dottedQuarterAccent != null) {
      map['dottedQuarterAccent'] =
          forQuery ? (dottedQuarterAccent! ? 1 : 0) : dottedQuarterAccent;
    } else if (dottedQuarterAccent != null || !forView) {
      map['dottedQuarterAccent'] = null;
    }
    if (accentBeatsPerBar != null || !forView) {
      map['accentBeatsPerBar'] = accentBeatsPerBar;
    }
    if (numberOfBars != null || !forView) {
      map['numberOfBars'] = numberOfBars;
    }
    if (trackId != null) {
      map['trackId'] = forView
          ? plTrack == null
              ? trackId
              : plTrack!.title
          : trackId;
    } else if (trackId != null || !forView) {
      map['trackId'] = null;
    }

    return map;
  }

  /// This method returns Json String [Tempo]
  @override
  String toJson() {
    return json.encode(toMap(forJson: true));
  }

  /// This method returns Json String [Tempo]
  @override
  Future<String> toJsonWithChilds() async {
    return json.encode(await toMapWithChildren(false, true));
  }

  @override
  List<dynamic> toArgs() {
    return [
      row__id,
      row__sortOrder,
      bpm,
      beatsPerBar,
      beatUnit,
      dottedQuarterAccent,
      accentBeatsPerBar,
      numberOfBars,
      trackId
    ];
  }

  @override
  List<dynamic> toArgsWithIds() {
    return [
      row__id,
      row__sortOrder,
      bpm,
      beatsPerBar,
      beatUnit,
      dottedQuarterAccent,
      accentBeatsPerBar,
      numberOfBars,
      trackId
    ];
  }

  static Future<List<Tempo>?> fromWebUrl(Uri uri,
      {Map<String, String>? headers}) async {
    try {
      final response = await http.get(uri, headers: headers);
      return await fromJson(response.body);
    } catch (e) {
      debugPrint(
          'SQFENTITY ERROR Tempo.fromWebUrl: ErrorMessage: ${e.toString()}');
      return null;
    }
  }

  Future<http.Response> postUrl(Uri uri, {Map<String, String>? headers}) {
    return http.post(uri, headers: headers, body: toJson());
  }

  static Future<List<Tempo>> fromJson(String jsonBody) async {
    final Iterable list = await json.decode(jsonBody) as Iterable;
    var objList = <Tempo>[];
    try {
      objList = list
          .map((tempo) => Tempo.fromMap(tempo as Map<String, dynamic>))
          .toList();
    } catch (e) {
      debugPrint(
          'SQFENTITY ERROR Tempo.fromJson: ErrorMessage: ${e.toString()}');
    }
    return objList;
  }

  static Future<List<Tempo>> fromMapList(List<dynamic> data,
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields,
      bool setDefaultValues = true}) async {
    final List<Tempo> objList = <Tempo>[];
    loadedFields = loadedFields ?? [];
    for (final map in data) {
      final obj = Tempo.fromMap(map as Map<String, dynamic>,
          setDefaultValues: setDefaultValues);
      // final List<String> _loadedFields = List<String>.from(loadedFields);

      // RELATIONSHIPS PRELOAD
      if (preload || loadParents) {
        loadedFields = loadedFields ?? [];
        if ((preloadFields == null ||
            loadParents ||
            preloadFields.contains('plTrack'))) {
          obj.plTrack =
              obj.plTrack ?? await obj.getTrack(loadParents: loadParents);
        }
      } // END RELATIONSHIPS PRELOAD

      objList.add(obj);
    }
    return objList;
  }

  /// returns Tempo by ID if exist, otherwise returns null
  /// Primary Keys: String? row__id
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  /// ex: getById(preload:true) -> Loads all related objects
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  /// ex: getById(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  /// <returns>returns [Tempo] if exist, otherwise returns null
  Future<Tempo?> getById(String? row__id,
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    if (row__id == null) {
      return null;
    }
    Tempo? obj;
    final data = await _mnTempo.getById([row__id]);
    if (data.length != 0) {
      obj = Tempo.fromMap(data[0] as Map<String, dynamic>);

      // RELATIONSHIPS PRELOAD
      if (preload || loadParents) {
        loadedFields = loadedFields ?? [];
        if ((preloadFields == null ||
            loadParents ||
            preloadFields.contains('plTrack'))) {
          obj.plTrack =
              obj.plTrack ?? await obj.getTrack(loadParents: loadParents);
        }
      } // END RELATIONSHIPS PRELOAD
    } else {
      obj = null;
    }
    return obj;
  }

  /// Saves the (Tempo) object. If the Primary Key (row__id) field is null, returns Error.
  /// INSERTS (If not exist) OR REPLACES (If exist) data while Primary Key is not null.
  /// Call the saveAs() method if you do not want to save it when there is another row with the same row__id
  /// <returns>Returns BoolResult
  @override
  Future<BoolResult> save({bool ignoreBatch = true}) async {
    final result = BoolResult(success: false);
    try {
      await _mnTempo.rawInsert(
          'INSERT ${isSaved! ? 'OR REPLACE' : ''} INTO Tempo (row__id, row__sortOrder, bpm, beatsPerBar, beatUnit, dottedQuarterAccent, accentBeatsPerBar, numberOfBars, trackId)  VALUES (?,?,?,?,?,?,?,?,?)',
          toArgsWithIds(),
          ignoreBatch);
      result.success = true;
      isSaved = true;
    } catch (e) {
      result.errorMessage = e.toString();
    }

    saveResult = result;
    return result;
  }

  /// saveAll method saves the sent List<Tempo> as a bulk in one transaction
  /// Returns a <List<BoolResult>>
  static Future<List<dynamic>> saveAll(List<Tempo> tempos,
      {bool? exclusive, bool? noResult, bool? continueOnError}) async {
    List<dynamic>? result = [];
    // If there is no open transaction, start one
    final isStartedBatch = await Setlistdb().batchStart();
    for (final obj in tempos) {
      await obj.save();
    }
    if (!isStartedBatch) {
      result = await Setlistdb().batchCommit(
          exclusive: exclusive,
          noResult: noResult,
          continueOnError: continueOnError);
    }
    return result!;
  }

  /// Updates if the record exists, otherwise adds a new row
  /// <returns>Returns 1
  @override
  Future<int?> upsert({bool ignoreBatch = true}) async {
    try {
      final result = await _mnTempo.rawInsert(
          'INSERT OR REPLACE INTO Tempo (row__id, row__sortOrder, bpm, beatsPerBar, beatUnit, dottedQuarterAccent, accentBeatsPerBar, numberOfBars, trackId)  VALUES (?,?,?,?,?,?,?,?,?)',
          [
            row__id,
            row__sortOrder,
            bpm,
            beatsPerBar,
            beatUnit,
            dottedQuarterAccent,
            accentBeatsPerBar,
            numberOfBars,
            trackId
          ],
          ignoreBatch);
      if (result! > 0) {
        saveResult = BoolResult(
            success: true,
            successMessage: 'Tempo row__id=$row__id updated successfully');
      } else {
        saveResult = BoolResult(
            success: false,
            errorMessage: 'Tempo row__id=$row__id did not update');
      }
      return 1;
    } catch (e) {
      saveResult = BoolResult(
          success: false,
          errorMessage: 'Tempo Save failed. Error: ${e.toString()}');
      return null;
    }
  }

  /// Deletes Tempo

  /// <returns>BoolResult res.success= true (Deleted), false (Could not be deleted)
  @override
  Future<BoolResult> delete([bool hardDelete = false]) async {
    debugPrint('SQFENTITIY: delete Tempo invoked (row__id=$row__id)');
    if (!_softDeleteActivated || hardDelete) {
      return _mnTempo.delete(
          QueryParams(whereString: 'row__id=?', whereArguments: [row__id]));
    } else {
      return _mnTempo.updateBatch(
          QueryParams(whereString: 'row__id=?', whereArguments: [row__id]),
          {'isDeleted': 1});
    }
  }

  @override
  Future<BoolResult> recover([bool recoverChilds = true]) {
    // not implemented because:
    final msg =
        'set useSoftDeleting:true in the table definition of [Tempo] to use this feature';
    throw UnimplementedError(msg);
  }

  @override
  TempoFilterBuilder select(
      {List<String>? columnsToSelect, bool? getIsDeleted}) {
    return TempoFilterBuilder(this, getIsDeleted)
      ..qparams.selectColumns = columnsToSelect;
  }

  @override
  TempoFilterBuilder distinct(
      {List<String>? columnsToSelect, bool? getIsDeleted}) {
    return TempoFilterBuilder(this, getIsDeleted)
      ..qparams.selectColumns = columnsToSelect
      ..qparams.distinct = true;
  }

  void _setDefaultValues() {
    isSaved = false;
    beatsPerBar = beatsPerBar ?? 4;
    beatUnit = beatUnit ?? 4;
    dottedQuarterAccent = dottedQuarterAccent ?? false;
    accentBeatsPerBar = accentBeatsPerBar ?? 1;
    numberOfBars = numberOfBars ?? 1000;
  }

  @override
  void rollbackPk() {
    if (isInsert == true) {
      row__id = null;
    }
  }

  // END METHODS
  // BEGIN CUSTOM CODE
  /*
      you can define customCode property of your SqfEntityTable constant. For example:
      const tablePerson = SqfEntityTable(
      tableName: 'person',
      primaryKeyName: 'id',
      primaryKeyType: PrimaryKeyType.integer_auto_incremental,
      fields: [
        SqfEntityField('firstName', DbType.text),
        SqfEntityField('lastName', DbType.text),
      ],
      customCode: '''
       String fullName()
       { 
         return '$firstName $lastName';
       }
      ''');
     */
  // END CUSTOM CODE
}
// endregion tempo

// region TempoField
class TempoField extends FilterBase {
  TempoField(TempoFilterBuilder tempoFB) : super(tempoFB);

  @override
  TempoFilterBuilder equals(dynamic pValue) {
    return super.equals(pValue) as TempoFilterBuilder;
  }

  @override
  TempoFilterBuilder equalsOrNull(dynamic pValue) {
    return super.equalsOrNull(pValue) as TempoFilterBuilder;
  }

  @override
  TempoFilterBuilder isNull() {
    return super.isNull() as TempoFilterBuilder;
  }

  @override
  TempoFilterBuilder contains(dynamic pValue) {
    return super.contains(pValue) as TempoFilterBuilder;
  }

  @override
  TempoFilterBuilder startsWith(dynamic pValue) {
    return super.startsWith(pValue) as TempoFilterBuilder;
  }

  @override
  TempoFilterBuilder endsWith(dynamic pValue) {
    return super.endsWith(pValue) as TempoFilterBuilder;
  }

  @override
  TempoFilterBuilder between(dynamic pFirst, dynamic pLast) {
    return super.between(pFirst, pLast) as TempoFilterBuilder;
  }

  @override
  TempoFilterBuilder greaterThan(dynamic pValue) {
    return super.greaterThan(pValue) as TempoFilterBuilder;
  }

  @override
  TempoFilterBuilder lessThan(dynamic pValue) {
    return super.lessThan(pValue) as TempoFilterBuilder;
  }

  @override
  TempoFilterBuilder greaterThanOrEquals(dynamic pValue) {
    return super.greaterThanOrEquals(pValue) as TempoFilterBuilder;
  }

  @override
  TempoFilterBuilder lessThanOrEquals(dynamic pValue) {
    return super.lessThanOrEquals(pValue) as TempoFilterBuilder;
  }

  @override
  TempoFilterBuilder inValues(dynamic pValue) {
    return super.inValues(pValue) as TempoFilterBuilder;
  }

  @override
  TempoField get not {
    return super.not as TempoField;
  }
}
// endregion TempoField

// region TempoFilterBuilder
class TempoFilterBuilder extends ConjunctionBase {
  TempoFilterBuilder(Tempo obj, bool? getIsDeleted) : super(obj, getIsDeleted) {
    _mnTempo = obj._mnTempo;
    _softDeleteActivated = obj.softDeleteActivated;
  }

  bool _softDeleteActivated = false;
  TempoManager? _mnTempo;

  /// put the sql keyword 'AND'
  @override
  TempoFilterBuilder get and {
    super.and;
    return this;
  }

  /// put the sql keyword 'OR'
  @override
  TempoFilterBuilder get or {
    super.or;
    return this;
  }

  /// open parentheses
  @override
  TempoFilterBuilder get startBlock {
    super.startBlock;
    return this;
  }

  /// String whereCriteria, write raw query without 'where' keyword. Like this: 'field1 like 'test%' and field2 = 3'
  @override
  TempoFilterBuilder where(String? whereCriteria, {dynamic parameterValue}) {
    super.where(whereCriteria, parameterValue: parameterValue);
    return this;
  }

  /// page = page number,
  /// pagesize = row(s) per page
  @override
  TempoFilterBuilder page(int page, int pagesize) {
    super.page(page, pagesize);
    return this;
  }

  /// int count = LIMIT
  @override
  TempoFilterBuilder top(int count) {
    super.top(count);
    return this;
  }

  /// close parentheses
  @override
  TempoFilterBuilder get endBlock {
    super.endBlock;
    return this;
  }

  /// argFields might be String or List<String>.
  /// Example 1: argFields='name, date'
  /// Example 2: argFields = ['name', 'date']
  @override
  TempoFilterBuilder orderBy(dynamic argFields) {
    super.orderBy(argFields);
    return this;
  }

  /// argFields might be String or List<String>.
  /// Example 1: argFields='field1, field2'
  /// Example 2: argFields = ['field1', 'field2']
  @override
  TempoFilterBuilder orderByDesc(dynamic argFields) {
    super.orderByDesc(argFields);
    return this;
  }

  /// argFields might be String or List<String>.
  /// Example 1: argFields='field1, field2'
  /// Example 2: argFields = ['field1', 'field2']
  @override
  TempoFilterBuilder groupBy(dynamic argFields) {
    super.groupBy(argFields);
    return this;
  }

  /// argFields might be String or List<String>.
  /// Example 1: argFields='name, date'
  /// Example 2: argFields = ['name', 'date']
  @override
  TempoFilterBuilder having(dynamic argFields) {
    super.having(argFields);
    return this;
  }

  TempoField _setField(TempoField? field, String colName, DbType dbtype) {
    return TempoField(this)
      ..param = DbParameter(
          dbType: dbtype, columnName: colName, wStartBlock: openedBlock);
  }

  TempoField? _row__id;
  TempoField get row__id {
    return _row__id = _setField(_row__id, 'row__id', DbType.integer);
  }

  TempoField? _row__sortOrder;
  TempoField get row__sortOrder {
    return _row__sortOrder =
        _setField(_row__sortOrder, 'row__sortOrder', DbType.integer);
  }

  TempoField? _bpm;
  TempoField get bpm {
    return _bpm = _setField(_bpm, 'bpm', DbType.real);
  }

  TempoField? _beatsPerBar;
  TempoField get beatsPerBar {
    return _beatsPerBar =
        _setField(_beatsPerBar, 'beatsPerBar', DbType.integer);
  }

  TempoField? _beatUnit;
  TempoField get beatUnit {
    return _beatUnit = _setField(_beatUnit, 'beatUnit', DbType.integer);
  }

  TempoField? _dottedQuarterAccent;
  TempoField get dottedQuarterAccent {
    return _dottedQuarterAccent =
        _setField(_dottedQuarterAccent, 'dottedQuarterAccent', DbType.bool);
  }

  TempoField? _accentBeatsPerBar;
  TempoField get accentBeatsPerBar {
    return _accentBeatsPerBar =
        _setField(_accentBeatsPerBar, 'accentBeatsPerBar', DbType.integer);
  }

  TempoField? _numberOfBars;
  TempoField get numberOfBars {
    return _numberOfBars =
        _setField(_numberOfBars, 'numberOfBars', DbType.real);
  }

  TempoField? _trackId;
  TempoField get trackId {
    return _trackId = _setField(_trackId, 'trackId', DbType.text);
  }

  /// Deletes List<Tempo> bulk by query
  ///
  /// <returns>BoolResult res.success= true (Deleted), false (Could not be deleted)
  @override
  Future<BoolResult> delete([bool hardDelete = false]) async {
    buildParameters();
    var r = BoolResult(success: false);

    if (_softDeleteActivated && !hardDelete) {
      r = await _mnTempo!.updateBatch(qparams, {'isDeleted': 1});
    } else {
      r = await _mnTempo!.delete(qparams);
    }
    return r;
  }

  /// using:
  /// update({'fieldName': Value})
  /// fieldName must be String. Value is dynamic, it can be any of the (int, bool, String.. )
  @override
  Future<BoolResult> update(Map<String, dynamic> values) {
    buildParameters();
    if (qparams.limit! > 0 || qparams.offset! > 0) {
      qparams.whereString =
          'row__id IN (SELECT row__id from Tempo ${qparams.whereString!.isNotEmpty ? 'WHERE ${qparams.whereString}' : ''}${qparams.limit! > 0 ? ' LIMIT ${qparams.limit}' : ''}${qparams.offset! > 0 ? ' OFFSET ${qparams.offset}' : ''})';
    }
    return _mnTempo!.updateBatch(qparams, values);
  }

  /// This method always returns [Tempo] Obj if exist, otherwise returns null
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  /// ex: toSingle(preload:true) -> Loads all related objects
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  /// ex: toSingle(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  /// <returns> Tempo?
  @override
  Future<Tempo?> toSingle(
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    buildParameters(pSize: 1);
    final objFuture = _mnTempo!.toList(qparams);
    final data = await objFuture;
    Tempo? obj;
    if (data.isNotEmpty) {
      obj = Tempo.fromMap(data[0] as Map<String, dynamic>);

      // RELATIONSHIPS PRELOAD
      if (preload || loadParents) {
        loadedFields = loadedFields ?? [];
        if ((preloadFields == null ||
            loadParents ||
            preloadFields.contains('plTrack'))) {
          obj.plTrack =
              obj.plTrack ?? await obj.getTrack(loadParents: loadParents);
        }
      } // END RELATIONSHIPS PRELOAD
    } else {
      obj = null;
    }
    return obj;
  }

  /// This method always returns [Tempo]
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  /// ex: toSingle(preload:true) -> Loads all related objects
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  /// ex: toSingle(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  /// <returns> Tempo?
  @override
  Future<Tempo> toSingleOrDefault(
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    return await toSingle(
            preload: preload,
            preloadFields: preloadFields,
            loadParents: loadParents,
            loadedFields: loadedFields) ??
        Tempo();
  }

  /// This method returns int. [Tempo]
  /// <returns>int
  @override
  Future<int> toCount([VoidCallback Function(int c)? tempoCount]) async {
    buildParameters();
    qparams.selectColumns = ['COUNT(1) AS CNT'];
    final temposFuture = await _mnTempo!.toList(qparams);
    final int count = temposFuture[0]['CNT'] as int;
    if (tempoCount != null) {
      tempoCount(count);
    }
    return count;
  }

  /// This method returns List<Tempo> [Tempo]
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  /// ex: toList(preload:true) -> Loads all related objects
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  /// ex: toList(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  /// <returns>List<Tempo>
  @override
  Future<List<Tempo>> toList(
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    final data = await toMapList();
    final List<Tempo> temposData = await Tempo.fromMapList(data,
        preload: preload,
        preloadFields: preloadFields,
        loadParents: loadParents,
        loadedFields: loadedFields,
        setDefaultValues: qparams.selectColumns == null);
    return temposData;
  }

  /// This method returns Json String [Tempo]
  @override
  Future<String> toJson() async {
    final list = <dynamic>[];
    final data = await toList();
    for (var o in data) {
      list.add(o.toMap(forJson: true));
    }
    return json.encode(list);
  }

  /// This method returns Json String. [Tempo]
  @override
  Future<String> toJsonWithChilds() async {
    final list = <dynamic>[];
    final data = await toList();
    for (var o in data) {
      list.add(await o.toMapWithChildren(false, true));
    }
    return json.encode(list);
  }

  /// This method returns List<dynamic>. [Tempo]
  /// <returns>List<dynamic>
  @override
  Future<List<dynamic>> toMapList() async {
    buildParameters();
    return await _mnTempo!.toList(qparams);
  }

  /// This method returns Primary Key List SQL and Parameters retVal = Map<String,dynamic>. [Tempo]
  /// retVal['sql'] = SQL statement string, retVal['args'] = whereArguments List<dynamic>;
  /// <returns>List<String>
  @override
  Map<String, dynamic> toListPrimaryKeySQL([bool buildParams = true]) {
    final Map<String, dynamic> _retVal = <String, dynamic>{};
    if (buildParams) {
      buildParameters();
    }
    _retVal['sql'] = 'SELECT `row__id` FROM Tempo WHERE ${qparams.whereString}';
    _retVal['args'] = qparams.whereArguments;
    return _retVal;
  }

  /// This method returns Primary Key List<String>.
  /// <returns>List<String>
  @override
  Future<List<String>> toListPrimaryKey([bool buildParams = true]) async {
    if (buildParams) {
      buildParameters();
    }
    final List<String> row__idData = <String>[];
    qparams.selectColumns = ['row__id'];
    final row__idFuture = await _mnTempo!.toList(qparams);

    final int count = row__idFuture.length;
    for (int i = 0; i < count; i++) {
      row__idData.add(row__idFuture[i]['row__id'] as String);
    }
    return row__idData;
  }

  /// Returns List<dynamic> for selected columns. Use this method for 'groupBy' with min,max,avg..  [Tempo]
  /// Sample usage: (see EXAMPLE 4.2 at https://github.com/hhtokpinar/sqfEntity#group-by)
  @override
  Future<List<dynamic>> toListObject() async {
    buildParameters();

    final objectFuture = _mnTempo!.toList(qparams);

    final List<dynamic> objectsData = <dynamic>[];
    final data = await objectFuture;
    final int count = data.length;
    for (int i = 0; i < count; i++) {
      objectsData.add(data[i]);
    }
    return objectsData;
  }

  /// Returns List<String> for selected first column
  /// Sample usage: await Tempo.select(columnsToSelect: ['columnName']).toListString()
  @override
  Future<List<String>> toListString(
      [VoidCallback Function(List<String> o)? listString]) async {
    buildParameters();

    final objectFuture = _mnTempo!.toList(qparams);

    final List<String> objectsData = <String>[];
    final data = await objectFuture;
    final int count = data.length;
    for (int i = 0; i < count; i++) {
      objectsData.add(data[i][qparams.selectColumns![0]].toString());
    }
    if (listString != null) {
      listString(objectsData);
    }
    return objectsData;
  }
}
// endregion TempoFilterBuilder

// region TempoFields
class TempoFields {
  static TableField? _fRow__id;
  static TableField get row__id {
    return _fRow__id =
        _fRow__id ?? SqlSyntax.setField(_fRow__id, 'row__id', DbType.integer);
  }

  static TableField? _fRow__sortOrder;
  static TableField get row__sortOrder {
    return _fRow__sortOrder = _fRow__sortOrder ??
        SqlSyntax.setField(_fRow__sortOrder, 'row__sortOrder', DbType.integer);
  }

  static TableField? _fBpm;
  static TableField get bpm {
    return _fBpm = _fBpm ?? SqlSyntax.setField(_fBpm, 'bpm', DbType.real);
  }

  static TableField? _fBeatsPerBar;
  static TableField get beatsPerBar {
    return _fBeatsPerBar = _fBeatsPerBar ??
        SqlSyntax.setField(_fBeatsPerBar, 'beatsPerBar', DbType.integer);
  }

  static TableField? _fBeatUnit;
  static TableField get beatUnit {
    return _fBeatUnit = _fBeatUnit ??
        SqlSyntax.setField(_fBeatUnit, 'beatUnit', DbType.integer);
  }

  static TableField? _fDottedQuarterAccent;
  static TableField get dottedQuarterAccent {
    return _fDottedQuarterAccent = _fDottedQuarterAccent ??
        SqlSyntax.setField(
            _fDottedQuarterAccent, 'dottedQuarterAccent', DbType.bool);
  }

  static TableField? _fAccentBeatsPerBar;
  static TableField get accentBeatsPerBar {
    return _fAccentBeatsPerBar = _fAccentBeatsPerBar ??
        SqlSyntax.setField(
            _fAccentBeatsPerBar, 'accentBeatsPerBar', DbType.integer);
  }

  static TableField? _fNumberOfBars;
  static TableField get numberOfBars {
    return _fNumberOfBars = _fNumberOfBars ??
        SqlSyntax.setField(_fNumberOfBars, 'numberOfBars', DbType.real);
  }

  static TableField? _fTrackId;
  static TableField get trackId {
    return _fTrackId =
        _fTrackId ?? SqlSyntax.setField(_fTrackId, 'trackId', DbType.text);
  }
}
// endregion TempoFields

//region TempoManager
class TempoManager extends SqfEntityProvider {
  TempoManager()
      : super(Setlistdb(),
            tableName: _tableName,
            primaryKeyList: _primaryKeyList,
            whereStr: _whereStr);
  static const String _tableName = 'Tempo';
  static const List<String> _primaryKeyList = ['row__id'];
  static const String _whereStr = 'row__id=?';
}

//endregion TempoManager
class SetlistdbSequenceManager extends SqfEntityProvider {
  SetlistdbSequenceManager() : super(Setlistdb());
}
// END OF ENTITIES
